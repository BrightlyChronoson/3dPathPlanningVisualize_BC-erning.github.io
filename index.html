<!DOCTYPE html>
<html>
<head>
    <title>ç¬¬å…­æ•™å­¦æ¥¼BåŒº3Dè·¯å¾„è§„åˆ’</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.9); 
            padding: 12px 15px; 
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px;
            color: #333;
            z-index: 100;
        }
        #mode-panel {
            position: absolute;
            top: 10px;
            left: 280px;
            background: rgba(255,255,255,0.9);
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
        }
        .mode-btn {
            padding: 6px 12px;
            margin: 0 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #f5f5f5;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .mode-btn:hover {
            background: #e9ecef;
        }
        .mode-btn.active:hover {
            background: #0069d9;
        }
        #path-detail {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            display: none;
            z-index: 100;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            color: #333;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .erroræç¤º {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">ç‚¹å‡»ç¬¬ä¸€ä¸ªé•¿æ–¹ä½“ä½œä¸ºèµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰ï¼Œç¬¬äºŒä¸ªä½œä¸ºç»ˆç‚¹ï¼ˆè“è‰²ï¼‰</div>
    <div id="mode-panel">
        <span style="font-size:13px; font-weight:bold; margin-right:8px;">é€‰æ‹©æ¨¡å¼ï¼š</span>
        <button class="mode-btn active" data-file="path_data_6J.json">æ•™å­¦æ¥¼æ¨¡å¼</button>
        <button class="mode-btn" data-file="path_data_campus.json">æ ¡å›­æ¨¡å¼</button>
    </div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">è·¯å¾„è¯¦æƒ…</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">å›¾ä¾‹</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span>æ•™å®¤/å»ºç­‘</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>æ‚¬åœç›®æ ‡</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>èµ·ç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>ç»ˆç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #006600;"></div>
            <span>è¿æ¥é€šé“</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>ç¬¬1æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>ç¬¬2æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
    </div>

    <script>
        // ========== æ–°å¢ï¼šæ¨¡å¼ä¸“å±é…ç½®ï¼ˆæ ¸å¿ƒå·®å¼‚åŒ–ç‚¹ï¼‰ ==========
        // æ•™å­¦æ¥¼æ¨¡å¼é…ç½®ï¼ˆé€‚é…å°èŒƒå›´ã€å«æ¥¼æ¢¯ï¼‰
        const teachingConfig = {
            SCALE: 100000000,         // åæ ‡ç¼©æ”¾ï¼ˆæ‹‰å¼€æ•™å®¤é—´è·ï¼‰
            ALTITUDE_SCALE: 1000,      // æµ·æ‹”ç¼©æ”¾ï¼ˆçªå‡ºæ¥¼å±‚å·®ï¼‰
            K: 2,
            BOX_SIZE: { x: 2000, y: 500, z: 2000 }, // æ•™å®¤é•¿æ–¹ä½“å¤§å°
            EDGE_RADIUS: 80,           // é€šé“åŠå¾„
            PATH_RADIUS: 80,           // è·¯å¾„åŠå¾„
            STAIR_PENALTY: true        // å¯ç”¨æ¥¼æ¢¯æƒ©ç½š
        };
        // æ ¡å›­æ¨¡å¼é…ç½®ï¼ˆé€‚é…å¤§èŒƒå›´ã€æ— æ¥¼æ¢¯ï¼‰
        const campusConfig = {
            SCALE: 100000000,           // åæ ‡ç¼©æ”¾ï¼ˆç¼©å°ï¼Œé¿å…æ ¡å›­åŒºåŸŸæº¢å‡ºï¼‰
            ALTITUDE_SCALE: 500,       // æµ·æ‹”ç¼©æ”¾ï¼ˆé™ä½å»ºç­‘é«˜åº¦å·®ï¼‰
            K: 2,
            BOX_SIZE: { x: 5000, y: 600, z: 5000 }, // å»ºç­‘é•¿æ–¹ä½“æ›´å¤§
            EDGE_RADIUS: 150,          // æ ¡å›­é“è·¯æ›´å®½
            PATH_RADIUS: 150,          // æ ¡å›­è·¯å¾„æ›´å®½
            STAIR_PENALTY: false       // ç¦ç”¨æ¥¼æ¢¯æƒ©ç½š
        };
        // å…¨å±€æ¨¡å¼çŠ¶æ€
        let currentMode = 'teaching'; // åˆå§‹ä¸ºæ•™å­¦æ¥¼æ¨¡å¼
        let currentConfig = teachingConfig;
        // ========== æ¨¡å¼é…ç½®ç»“æŸ ==========


        let minLon = 0, minLat = 0;
        let nodes = {};         // èŠ‚ç‚¹æ•°æ®
        let edges = {};         // è¾¹æ•°æ®
        let selectedNodes = []; // é€‰ä¸­èŠ‚ç‚¹
        let pathMeshes = [];    // è·¯å¾„ç½‘æ ¼
        let pathData = [];      // è·¯å¾„è¯¦æƒ…
        let nodeMeshes = [];    // èŠ‚ç‚¹ç½‘æ ¼ï¼ˆç”¨äºæ¸…ç©ºï¼‰
        let edgeMeshes = [];    // è¾¹ç½‘æ ¼ï¼ˆç”¨äºæ¸…ç©ºï¼‰


        // 2. Three.jsæ ¸å¿ƒå¯¹è±¡åˆå§‹åŒ–ï¼ˆå®Œå…¨ä¿ç•™ï¼‰
        const scene = new THREE.Scene();
        const skyCanvas = document.createElement('canvas');
        skyCanvas.width = 256; 
        skyCanvas.height = 256;
        const skyCtx = skyCanvas.getContext('2d');
        const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 256);
        skyGrad.addColorStop(0, '#E0F7FF'); 
        skyGrad.addColorStop(1, '#87CEEB'); 
        skyCtx.fillStyle = skyGrad;
        skyCtx.fillRect(0, 0, 256, 256);
        const skyTexture = new THREE.CanvasTexture(skyCanvas);
        scene.background = skyTexture;

        const camera = new THREE.PerspectiveCamera(
            55,                  
            window.innerWidth / window.innerHeight,
            0.1,
            500000
        );
        camera.position.set(20000, 15000, 20000); 
        camera.lookAt(new THREE.Vector3(0, 70, 0));

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 5000;  
        controls.maxDistance = 100000;
        controls.target.set(0, 70, 0);
        controls.maxPolarAngle = Math.PI / 2;


        // 3. å…‰ç…§ç³»ç»Ÿï¼ˆå®Œå…¨ä¿ç•™ï¼‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50000, 80000, 50000);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 200000;
        dirLight.shadow.camera.left = -50000;
        dirLight.shadow.camera.right = 50000;
        dirLight.shadow.camera.top = 50000;
        dirLight.shadow.camera.bottom = -50000;
        scene.add(dirLight);


        // 4. è¾…åŠ©å…ƒç´ ï¼ˆå®Œå…¨ä¿ç•™ï¼‰
        const floorGeometry = new THREE.PlaneGeometry(300000, 300000); 
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0f0f0, 
            roughness: 0.8,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);


        // 5. å·¥å…·å‡½æ•°ï¼ˆé€‚é…æ¨¡å¼é…ç½®ï¼‰
        function lonlatTo3d(lon, lat, alt) {
            // ä½¿ç”¨å½“å‰æ¨¡å¼çš„ç¼©æ”¾å‚æ•°
            const x = (lon - minLon) * currentConfig.SCALE - 35000;
            const y = alt * currentConfig.ALTITUDE_SCALE - 58500;
            const z = (lat - minLat) * currentConfig.SCALE - 20000;
            return new THREE.Vector3(x, y, z);
        }

        function getColorByAlt(alt) {
            return 0x999999; // ç»Ÿä¸€ç°è‰²ï¼ˆä¿ç•™ï¼‰
        }

        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="erroræç¤º">${text}</span>` : text;
        }

        function clearScene() {
            // æ¸…ç©ºè·¯å¾„/èŠ‚ç‚¹/è¾¹ç½‘æ ¼ï¼ˆä¿ç•™ï¼‰
            pathMeshes.forEach(mesh => scene.remove(mesh));
            nodeMeshes.forEach(mesh => scene.remove(mesh));
            edgeMeshes.forEach(mesh => scene.remove(mesh));
            // é‡ç½®å˜é‡ï¼ˆä¿ç•™ï¼‰
            nodes = {}; edges = {}; selectedNodes = []; pathData = [];
            minLon = 0; minLat = 0;
            pathMeshes = []; nodeMeshes = []; edgeMeshes = [];
            // æ¸…ç©ºé¢æ¿ï¼ˆä¿ç•™ï¼‰
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';
            updateInfo("ç‚¹å‡»ç¬¬ä¸€ä¸ªé•¿æ–¹ä½“ä½œä¸ºèµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰ï¼Œç¬¬äºŒä¸ªä½œä¸ºç»ˆç‚¹ï¼ˆè“è‰²ï¼‰");
        }


        // 6. ç»˜åˆ¶å‡½æ•°ï¼ˆé€‚é…æ¨¡å¼é…ç½®ï¼‰
        function drawEdges() {
            const processed = new Set();
            for (const start in edges) {
                for (const end in edges[start]) {
                    const key = `${start}-${end}`;
                    const reverseKey = `${end}-${start}`;
                    if (processed.has(key) || processed.has(reverseKey)) continue;
                    processed.add(key);
                    if (!nodes[start] || !nodes[end]) continue;

                    // æ‹¥æŒ¤åº¦é¢œè‰²é€»è¾‘ï¼ˆä¿ç•™ï¼‰
                    const edgeData = edges[start][end];
                    const crowd = edgeData.max_cap === 0 ? 0 : Math.min(Math.max(edgeData.actual_flow / edgeData.max_cap, 0), 1);
                    let edgeColor = crowd < 0.5 ? 0x006600 : (crowd <= 0.8 ? 0xffff00 : 0xff0000);

                    // æè´¨ï¼ˆä¿ç•™ï¼‰
                    const sideRoadMat = new THREE.MeshStandardMaterial({
                        color: edgeColor, roughness:0.7, metalness:0.1,
                        transparent: true, opacity: 0.8
                    });

                    // åæ ‡è®¡ç®—ï¼ˆä¿ç•™ï¼‰
                    const startPos = lonlatTo3d(nodes[start].lon, nodes[start].lat, nodes[start].alt);
                    const endPos = lonlatTo3d(nodes[end].lon, nodes[end].lat, nodes[end].alt);
                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                    // ========== é€‚é…æ¨¡å¼ï¼šä½¿ç”¨å½“å‰æ¨¡å¼çš„é€šé“åŠå¾„ ==========
                    const cylinderGeo = new THREE.CylinderGeometry(
                        currentConfig.EDGE_RADIUS,
                        currentConfig.EDGE_RADIUS,
                        length,
                        32
                    );
                    // ========== é€‚é…ç»“æŸ ==========

                    const cylinderMesh = new THREE.Mesh(cylinderGeo, sideRoadMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);
                    scene.add(cylinderMesh);
                    edges[start][end].mesh = cylinderMesh;
                    edgeMeshes.push(cylinderMesh);
                }
            }
            updateInfo(`å·²åŠ è½½ ${processed.size} æ¡é€šé“ï¼ˆ${currentMode === 'teaching' ? 'æ•™å­¦æ¥¼' : 'æ ¡å›­'}æ¨¡å¼ï¼‰`);
        }

        function drawNodes() {
            for (const id in nodes) {
                const node = nodes[id];
                const pos = lonlatTo3d(node.lon, node.lat, node.alt);
                const alt = node.alt;

                // ========== é€‚é…æ¨¡å¼ï¼šä½¿ç”¨å½“å‰æ¨¡å¼çš„é•¿æ–¹ä½“å¤§å° ==========
                const boxGeo = new THREE.BoxGeometry(
                    currentConfig.BOX_SIZE.x,
                    currentConfig.BOX_SIZE.y,
                    currentConfig.BOX_SIZE.z
                );
                // ========== é€‚é…ç»“æŸ ==========

                // æè´¨ï¼ˆä¿ç•™ï¼‰
                const baseColor = getColorByAlt(alt);
                const materials = {
                    default: new THREE.MeshStandardMaterial({color: baseColor, roughness:0.7, metalness:0.1}),
                    hover: new THREE.MeshStandardMaterial({color: baseColor, emissive: 0xffff00, emissiveIntensity: 0.3, roughness:0.7, metalness:0.1}),
                    start: new THREE.MeshStandardMaterial({color: 0x4CAF50, roughness:0.7, metalness:0.1}),
                    end: new THREE.MeshStandardMaterial({color: 0x0000ff, roughness:0.7, metalness:0.1})
                };

                const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                boxMesh.position.copy(pos);
                boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                scene.add(boxMesh);
                nodeMeshes.push(boxMesh);

                nodes[id] = {
                    ...node,
                    mesh: boxMesh,
                    materials,
                    originalScale: new THREE.Vector3(1, 1, 1)
                };
            }
        }

        function drawPath(path, index, color) {
            const pathMat = new THREE.MeshStandardMaterial({
                color: color, roughness: 0.7, metalness: 0.1,
                transparent: true, opacity: 0.9
            });

            for(let i = 0; i < path.length - 1; i++) {
                const nodeId1 = path[i];
                const nodeId2 = path[i+1];
                const startPos = nodes[nodeId1].mesh.position.clone();
                const endPos = nodes[nodeId2].mesh.position.clone();

                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                // ========== é€‚é…æ¨¡å¼ï¼šä½¿ç”¨å½“å‰æ¨¡å¼çš„è·¯å¾„åŠå¾„ ==========
                const cylinderGeo = new THREE.CylinderGeometry(
                    currentConfig.PATH_RADIUS,
                    currentConfig.PATH_RADIUS,
                    length,
                    32
                );
                // ========== é€‚é…ç»“æŸ ==========

                const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                cylinderMesh.position.copy(midPoint);
                cylinderMesh.lookAt(endPos);
                cylinderMesh.rotateX(Math.PI / 2);
                scene.add(cylinderMesh);
                pathMeshes.push(cylinderMesh);
            }

            // è·¯å¾„è¯¦æƒ…ï¼ˆä¿ç•™ï¼Œä»…è°ƒæ•´æ–‡å­—é€‚é…æ¨¡å¼ï¼‰
            const weight = calculatePathWeight(path);
            const length = calculatePathLength(path);
            pathData.push({ index, nodes: path, weight, length });
            const pathEl = document.getElementById(`path${index}`);
            pathEl.innerHTML = `
                <div style="font-weight: bold;">ç¬¬${index}æ¡æœ€çŸ­è·¯å¾„</div>
                <div>${currentMode === 'teaching' ? 'æ•™å®¤' : 'å»ºç­‘'}åºåˆ—ï¼š${path.join(' â†’ ')}</div>
                <div>é€šé“æ€»é•¿ï¼š${length.toFixed(2)} ç±³</div>
                <div>ç»¼åˆæƒé‡ï¼š${weight.toFixed(2)}</div>
            `;
            document.getElementById('path-detail').style.display = 'block';
        }


        // 7. æƒé‡/è·¯å¾„ç®—æ³•ï¼ˆé€‚é…æ¨¡å¼ï¼‰
        function calculateEdgeWeight(startId, endId) {
            if (!edges[startId] || !edges[startId][endId]) return Infinity;
            const start = nodes[startId];
            const end = nodes[endId];
            const edge = edges[startId][endId];

            // åŸºç¡€è·ç¦»è®¡ç®—ï¼ˆä¿ç•™ï¼‰
            const x1 = start.lon * 111000;
            const y1 = start.lat * 111000;
            const x2 = end.lon * 111000;
            const y2 = end.lat * 111000;
            let geoDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const altDiff = Math.abs(end.alt - start.alt);
            if (geoDist < 0.1) geoDist = altDiff + 10;

            // ========== é€‚é…æ¨¡å¼ï¼šä»…æ•™å­¦æ¥¼å¯ç”¨æ¥¼æ¢¯æƒ©ç½š ==========
            let stairPenalty = 1;
            if (currentConfig.STAIR_PENALTY) {
                const isStairEdge = startId.includes("STAIR") || endId.includes("STAIR");
                if (isStairEdge) stairPenalty = altDiff < 5 ? 30 : 80;
            }
            // ========== é€‚é…ç»“æŸ ==========

            // æ‹¥æŒ¤åº¦æƒ©ç½šï¼ˆä¿ç•™ï¼‰
            const maxCap = edge.max_cap || 1;
            const actualFlow = edge.actual_flow || 0;
            const congestion = actualFlow / maxCap;
            let crowdPenalty = 1;
            if (congestion <= 0.5) crowdPenalty = Math.pow(4, 5 * congestion);
            else if (congestion <= 0.8) crowdPenalty = Math.pow(8, 6 * (congestion - 0.5)) * 32;
            else crowdPenalty = Math.pow(15, 8 * (congestion - 0.8)) * 8384;

            // é“è·¯ç±»å‹ç³»æ•°ï¼ˆä¿ç•™ï¼‰
            const roadCoeff = edge.road_type === 'main' ? 0.9 : 1.2;

            // æœ€ç»ˆæƒé‡ï¼ˆä¿ç•™ï¼‰
            const finalWeight = geoDist * roadCoeff * stairPenalty * crowdPenalty;
            return finalWeight > 1e12 ? 1e12 : finalWeight;
        }

        // å…¶ä½™ç®—æ³•ï¼ˆcalculatePathWeightã€calculatePathLengthã€dijkstraã€yenKShortestPathsï¼‰å®Œå…¨ä¿ç•™
        function calculatePathWeight(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                total += calculateEdgeWeight(path[i], path[i + 1]);
            }
            return total;
        }

        function calculatePathLength(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const start = nodes[path[i]];
                const end = nodes[path[i + 1]];
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                const planeDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const altDiff = end.alt - start.alt;
                const altDist = Math.abs(altDiff);
                const spaceDist = Math.sqrt(Math.pow(planeDist, 2) + Math.pow(altDist, 2));
                total += spaceDist;
            }
            return total;
        }

        function dijkstra(startId, endId) {
            const distances = {};
            const predecessors = {};
            const unvisited = new Set(Object.keys(nodes));
            Object.keys(nodes).forEach(id => {
                distances[id] = Infinity;
                predecessors[id] = null;
            });
            distances[startId] = 0;
            while (unvisited.size > 0) {
                let currentId = null;
                let minDist = Infinity;
                for (const id of unvisited) {
                    if (distances[id] < minDist) {
                        minDist = distances[id];
                        currentId = id;
                    }
                }
                if (currentId === null || currentId === endId) break;
                unvisited.delete(currentId);
                for (const neighborId in edges[currentId]) {
                    if (!unvisited.has(neighborId)) continue;
                    const newDist = distances[currentId] + calculateEdgeWeight(currentId, neighborId);
                    if (newDist < distances[neighborId]) {
                        distances[neighborId] = newDist;
                        predecessors[neighborId] = currentId;
                    }
                }
            }
            const path = [];
            let current = endId;
            while (current !== null) {
                path.push(current);
                current = predecessors[current];
            }
            path.reverse();
            return path[0] === startId ? path : null;
        }

        function yenKShortestPaths(startId, endId, K) {
            const kPaths = [];
            const firstPath = dijkstra(startId, endId);
            if (!firstPath) return [];
            kPaths.push(firstPath);
            for (let k = 1; k < K; k++) {
                const prevPath = kPaths[k-1];
                const candidates = [];
                for (let i = 0; i < prevPath.length - 1; i++) {
                    const spurNode = prevPath[i];
                    const rootPath = prevPath.slice(0, i+1);
                    const removedEdges = new Map();
                    kPaths.forEach(path => {
                        if (path.slice(0, i+1).join(',') === rootPath.join(',')) {
                            const edgeKey = `${path[i]}-${path[i+1]}`;
                            if (edges[path[i]]?.[path[i+1]]) {
                                removedEdges.set(edgeKey, edges[path[i]][path[i+1]]);
                                delete edges[path[i]][path[i+1]];
                            }
                        }
                    });
                    const spurPath = dijkstra(spurNode, endId);
                    if (spurPath) {
                        const newPath = [...rootPath.slice(0, -1), ...spurPath];
                        const isDuplicate = kPaths.some(existPath => 
                            existPath.length === newPath.length && existPath.join(',') === newPath.join(',')
                        );
                        if (!isDuplicate) {
                            candidates.push({path: newPath, weight: calculatePathWeight(newPath)});
                        }
                    }
                    removedEdges.forEach((edge, edgeKey) => {
                        const [u, v] = edgeKey.split('-');
                        if (!edges[u]) edges[u] = {};
                        edges[u][v] = edge;
                    });
                }
                if (candidates.length === 0) break;
                candidates.sort((a, b) => a.weight - b.weight);
                kPaths.push(candidates[0].path);
            }
            return kPaths;
        }


        // 8. äº¤äº’é€»è¾‘ï¼ˆä»…é€‚é…æ¨¡å¼æç¤ºæ–‡å­—ï¼‰
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNodeId = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(nodes).map(n => n.mesh), false);
            if (hoveredNodeId && !selectedNodes.includes(hoveredNodeId)) {
                const prevNode = nodes[hoveredNodeId];
                prevNode.mesh.material = prevNode.materials.default;
                prevNode.mesh.scale.copy(prevNode.originalScale);
                hoveredNodeId = null;
            }
            if (intersects.length > 0) {
                const targetNode = intersects[0].object;
                const nodeId = targetNode.userData.id;
                if (!selectedNodes.includes(nodeId)) {
                    hoveredNodeId = nodeId;
                    const currNode = nodes[nodeId];
                    currNode.mesh.material = currNode.materials.hover;
                    currNode.mesh.scale.set(1.2, 1.2, 1.2);
                }
            }
        }

        function onMouseClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(nodes).map(n => n.mesh), false);
            if (intersects.length === 0) {
                // é€‚é…æ¨¡å¼ï¼šæç¤ºæ–‡å­—åŒºåˆ†â€œæ•™å®¤â€/â€œå»ºç­‘â€
                updateInfo(`è¯·ç‚¹å‡»æœ‰æ•ˆ${currentMode === 'teaching' ? 'æ•™å®¤' : 'å»ºç­‘'}ï¼ˆç°è‰²é•¿æ–¹ä½“ï¼‰`, true);
                return;
            }
            const targetNode = intersects[0].object;
            const nodeId = targetNode.userData.id;

            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];
            pathData = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';

            if (selectedNodes.length === 0) {
                selectedNodes.push(nodeId);
                nodes[nodeId].mesh.material = nodes[nodeId].materials.start;
                nodes[nodeId].mesh.scale.copy(nodes[nodeId].originalScale);
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            } else if (selectedNodes.length === 1) {
                if (nodeId === selectedNodes[0]) {
                    updateInfo("âŒ ä¸èƒ½é€‰æ‹©åŒä¸€é•¿æ–¹ä½“ä½œä¸ºç»ˆç‚¹ï¼Œè¯·é‡æ–°ç‚¹å‡»", true);
                    return;
                }
                selectedNodes.push(nodeId);
                nodes[nodeId].mesh.material = nodes[nodeId].materials.end;
                nodes[nodeId].mesh.scale.copy(nodes[nodeId].originalScale);
                updateInfo(`ğŸ” æ­£åœ¨è®¡ç®—è·¯å¾„ï¼š${selectedNodes[0]} â†’ ${nodeId}`);
                const kPaths = yenKShortestPaths(selectedNodes[0], nodeId, currentConfig.K);
                if (kPaths.length === 0) {
                    updateInfo(`âŒ æœªæ‰¾åˆ°ä» ${selectedNodes[0]} åˆ° ${nodeId} çš„è·¯å¾„`, true);
                } else {
                    updateInfo(`âœ… æ‰¾åˆ° ${kPaths.length} æ¡è·¯å¾„ï¼Œç‚¹å‡»ç©ºç™½å¤„é‡æ–°é€‰æ‹©`);
                    const pathColors = [0x00ffff, 0x8800ff];                
                    kPaths.forEach((path, idx) => {
                        drawPath(path, idx + 1, pathColors[idx]);
                    });
                }
            } else {
                selectedNodes.forEach(id => {
                    nodes[id].mesh.material = nodes[id].materials.default;
                    nodes[id].mesh.scale.copy(nodes[id].originalScale);
                });
                selectedNodes = [nodeId];
                nodes[nodeId].mesh.material = nodes[nodeId].materials.start;
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            }
        }


        // 9. æ•°æ®åŠ è½½ï¼ˆå¢åŠ æ¨¡å¼é…ç½®åˆ‡æ¢ï¼‰
        function loadData(fileName) {
            clearScene();
            // åˆ‡æ¢å½“å‰æ¨¡å¼&é…ç½®
            currentMode = fileName === 'path_data_6J.json' ? 'teaching' : 'campus';
            currentConfig = currentMode === 'teaching' ? teachingConfig : campusConfig;
            
            fetch(fileName)
                .then(response => {
                    if (!response.ok) throw new Error(`æ•°æ®åŠ è½½å¤±è´¥ï¼ˆ${response.status}ï¼‰`);
                    return response.json();
                })
                .then(data => {
                    minLon = data.min_lon;
                    minLat = data.min_lat;
                    nodes = data.nodes;
                    edges = data.edges;
                    if (!nodes || Object.keys(nodes).length === 0) throw new Error("èŠ‚ç‚¹æ•°æ®ä¸ºç©º");
                    if (!edges || Object.keys(edges).length === 0) throw new Error("è¾¹æ•°æ®ä¸ºç©º");
                    drawEdges();
                    drawNodes();
                })
                .catch(error => {
                    updateInfo(`âš ï¸ åˆå§‹åŒ–å¤±è´¥ï¼š${error.message}`, true);
                    if (error.message.includes('404')) {
                        updateInfo(`âš ï¸ æœªæ‰¾åˆ°${fileName}ï¼ˆè¯·ç¡®ä¿ä¸index.htmlåŒç›®å½•ï¼‰`, true);
                    } else if (error.message.includes('JSON')) {
                        updateInfo(`âš ï¸ ${fileName}æ ¼å¼é”™è¯¯ï¼ˆé‡æ–°è¿è¡ŒPythonå¯¼å‡ºï¼‰`, true);
                    }
                });
        }


        // 10. äº‹ä»¶ç»‘å®šï¼ˆå®Œå…¨ä¿ç•™ï¼‰
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                const fileName = this.getAttribute('data-file');
                loadData(fileName);
            });
        });

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // åˆå§‹åŒ–åŠ è½½æ•™å­¦æ¥¼æ¨¡å¼
        loadData('path_data_6J.json');
        animate();
    </script>
</body>
</html>

