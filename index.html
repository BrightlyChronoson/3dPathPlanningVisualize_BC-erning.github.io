    <!DOCTYPE html>
<html>
<head>
    <title>ç¬¬å…­æ•™å­¦æ¥¼BåŒº3Dè·¯å¾„è§„åˆ’</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.9); 
            padding: 12px 15px; 
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px;
            color: #333;
            z-index: 100;
        }
        #path-detail {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            display: none;
            z-index: 100;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            color: #333;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .erroræç¤º {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">ç‚¹å‡»ç¬¬ä¸€ä¸ªé•¿æ–¹ä½“ä½œä¸ºèµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰ï¼Œç¬¬äºŒä¸ªä½œä¸ºç»ˆç‚¹ï¼ˆè“è‰²ï¼‰</div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">è·¯å¾„è¯¦æƒ…</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">å›¾ä¾‹</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span>æ•™å®¤</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>æ‚¬åœæ•™å®¤</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>èµ·ç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>ç»ˆç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #006600;"></div>
            <span>è¿æ¥é€šé“</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>ç¬¬1æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>ç¬¬2æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
    </div>

    <script>
        // 1. å…¨å±€é…ç½®ï¼šä¿®æ­£åæ ‡è½´æ˜ å°„
        const CONFIG = {
            SCALE: 100000000,         // åæ ‡ç¼©æ”¾ç³»æ•°ï¼ˆæ‹‰å¼€æ°´å¹³è·ç¦»ï¼‰
            ALTITUDE_SCALE:1000,
            K: 2,                 // æœ€çŸ­è·¯å¾„æ•°é‡
            BOX_SIZE: { x: 2000, y: 500, z: 2000 }, // é•¿æ–¹ä½“ï¼šx/zæ°´å¹³ï¼Œyå‚ç›´ï¼ˆæ¥¼å±‚é«˜åº¦ï¼‰
            EDGE_WIDTH: 15,        // é€šé“å®½åº¦
            PATH_WIDTH: 20        // è·¯å¾„å®½åº¦
        };
        let minLon = 0, minLat = 0;
        let nodes = {};         // èŠ‚ç‚¹æ•°æ®
        let edges = {};         // è¾¹æ•°æ®
        let selectedNodes = []; // é€‰ä¸­èŠ‚ç‚¹
        let pathMeshes = [];    // è·¯å¾„ç½‘æ ¼
        let pathData = [];      // è·¯å¾„è¯¦æƒ…

        // 2. Three.jsæ ¸å¿ƒå¯¹è±¡åˆå§‹åŒ–
        const scene = new THREE.Scene();
        // æ–°å¢ï¼šæ¸å˜å¤©ç©ºç”»å¸ƒ
        const skyCanvas = document.createElement('canvas');
        skyCanvas.width = 256; 
        skyCanvas.height = 256;
        const skyCtx = skyCanvas.getContext('2d');
        const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 256);
        skyGrad.addColorStop(0, '#E0F7FF'); // é¡¶éƒ¨æµ…é’è“
        skyGrad.addColorStop(1, '#87CEEB'); // åº•éƒ¨å¤©ç©ºè“
        skyCtx.fillStyle = skyGrad;
        skyCtx.fillRect(0, 0, 256, 256);
        const skyTexture = new THREE.CanvasTexture(skyCanvas);
        scene.background = skyTexture;

        // ç›¸æœºï¼šé€‚é…yè½´ä¸ºé«˜åº¦ï¼Œè®¾ç½®æ°´å¹³è§†è§’
        const camera = new THREE.PerspectiveCamera(
            55,                  
            window.innerWidth / window.innerHeight,
            0.1,
            500000
        );
        camera.position.set(20000, 15000, 20000); // è°ƒæ•´ä¸ºæ°´å¹³æˆ–ç¨é«˜è§†è§’ï¼Œé¿å…ä»ä¸‹å¾€ä¸Šçœ‹
        camera.lookAt(new THREE.Vector3(0, 70, 0)); // çœ‹å‘åœºæ™¯ä¸­å¿ƒ

        // æ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // æ–°å¢ï¼šè½¯é˜´å½±ï¼Œè¾¹ç¼˜ä¸ç”Ÿç¡¬
        document.body.appendChild(renderer.domElement);

        // è½¨é“æ§åˆ¶å™¨ï¼šé™åˆ¶ç›¸æœºè§’åº¦ï¼Œä¸å…è®¸ä»ä¸‹æ–¹æŸ¥çœ‹
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 5000;  
        controls.maxDistance = 100000;
        controls.target.set(0, 70, 0);
        controls.maxPolarAngle = Math.PI / 2; // é™åˆ¶æœ€å¤§æè§’ä¸º90åº¦ï¼ˆæ°´å¹³è§†è§’ï¼‰

        // 3. å…‰ç…§ç³»ç»Ÿ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // é™ä½ç¯å¢ƒå…‰å¼ºåº¦ï¼Œé¿å…è¿‡äº®
        scene.add(ambientLight);
        // æ–¹å‘å…‰ï¼ˆæ›¿ä»£èšå…‰ç¯ï¼Œæ›´è‡ªç„¶çš„å¤ªé˜³å…‰ï¼‰
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50000, 80000, 50000); // æ›´é«˜çš„æ–œä¸Šæ–¹å…‰æº
        dirLight.castShadow = true;
        // ä¼˜åŒ–é˜´å½±è´¨é‡
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 200000;
        dirLight.shadow.camera.left = -50000;
        dirLight.shadow.camera.right = 50000;
        dirLight.shadow.camera.top = 50000;
        dirLight.shadow.camera.bottom = -50000;
        scene.add(dirLight);

        // 4. è¾…åŠ©å…ƒç´ 
        const floorGeometry = new THREE.PlaneGeometry(300000, 300000); 
        // ä¼˜åŒ–åœ°æ¿æè´¨ï¼šæ”¹ç”¨ç‰©ç†æè´¨ï¼Œå¢åŠ è´¨æ„Ÿ
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, // æ›´æŸ”å’Œçš„æµ…ç°è‰²
            roughness: 0.8,  // å“‘å…‰è´¨æ„Ÿ
            metalness: 0.1   // éé‡‘å±
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);

        // 5. å·¥å…·å‡½æ•°ï¼šä¿®æ­£åæ ‡æ˜ å°„ï¼ˆæµ·æ‹”â†’yè½´ï¼‰
        function lonlatTo3d(lon, lat, alt) {
            const x = (lon - minLon) * CONFIG.SCALE - 35000; // ç»åº¦â†’xè½´ï¼ˆæ°´å¹³ï¼‰
            const y = alt * CONFIG.ALTITUDE_SCALE - 60000;   // æµ·æ‹”â†’yè½´ï¼ˆå‚ç›´é«˜åº¦ï¼‰
            const z = (lat - minLat) * CONFIG.SCALE - 12000; // çº¬åº¦â†’zè½´ï¼ˆæ°´å¹³ï¼‰
            return new THREE.Vector3(x, y, z);
        }

        // ç»Ÿä¸€ä½¿ç”¨ç°è‰²è¡¨ç¤ºæœªé€‰æ‹©çš„æ•™å®¤
        function getColorByAlt(alt) {
            return 0x999999; // ç°è‰²
        }

        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="erroræç¤º">${text}</span>` : text;
        }

        // 6. ç»˜åˆ¶å‡½æ•°

        function drawEdges() {
            // ç§»é™¤å…¨å±€å›ºå®šæè´¨ï¼Œæ”¹ä¸ºåœ¨å¾ªç¯å†…ä¸ºæ¯ä¸ªè¾¹å•ç‹¬åˆ›å»º
            const processed = new Set();
            for (const start in edges) {
                for (const end in edges[start]) {
                    const key = `${start}-${end}`;
                    const reverseKey = `${end}-${start}`;
                    if (processed.has(key) || processed.has(reverseKey)) continue;
                    processed.add(key);

                    if (!nodes[start] || !nodes[end]) continue;

            // ========== æ–°å¢ï¼šè®¡ç®—å½“å‰è¾¹çš„æ‹¥æŒ¤åº¦å¹¶è®¾ç½®é¢œè‰² ==========
            // è·å–å½“å‰è¾¹çš„ actual_flow å’Œ max_cap æ•°æ®
                    const edgeData = edges[start][end];
            // è®¡ç®—æ‹¥æŒ¤åº¦ï¼ˆé™åˆ¶ 0~1 èŒƒå›´ï¼Œé¿å…æ•°æ®å¼‚å¸¸ï¼‰
                    const crowd = edgeData.max_cap === 0 
                        ? 0 // é¿å…é™¤ä»¥0æŠ¥é”™
                        : Math.min(Math.max(edgeData.actual_flow / edgeData.max_cap, 0), 1);
            
            // æŒ‰åŒºé—´è®¾ç½®é¢œè‰²ï¼ˆä¿ç•™ä½ åŸæœ‰çš„ç»¿è‰²å€¼ 0x006600ï¼‰
                    let edgeColor;
                    if (crowd < 0.5) {
                        edgeColor = 0x006600; // åŸæœ‰ç»¿è‰²
                    } else if (crowd <= 0.8) {
                        edgeColor = 0xffff00; // é»„è‰²
                    } else {
                        edgeColor = 0xff0000; // çº¢è‰²
                    }

            // æ¯ä¸ªè¾¹å•ç‹¬åˆ›å»ºæè´¨ï¼ˆç§»åˆ°å¾ªç¯å†…ï¼Œä½¿ç”¨åŠ¨æ€é¢œè‰²ï¼‰
                    const sideRoadMat = new THREE.MeshLambertMaterial({
                        color: edgeColor,     // åŠ¨æ€é¢œè‰²
                        transparent: true,    // ä¿ç•™åŸæœ‰é€æ˜å±æ€§
                        opacity: 0.8          // ä¿ç•™åŸæœ‰ä¸é€æ˜åº¦
                    });
            // ======================================================

            // ä»¥ä¸‹æ‰€æœ‰é€»è¾‘å®Œå…¨ä¿ç•™ï¼Œæ— ä»»ä½•ä¿®æ”¹
                    const startPos = lonlatTo3d(
                        nodes[start].lon,
                        nodes[start].lat,
                        nodes[start].alt
                    );
                    const endPos = lonlatTo3d(
                        nodes[end].lon,
                        nodes[end].lat,
                        nodes[end].alt
                    );

                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                    const cylinderRadius = 80;
                    const cylinderGeo = new THREE.CylinderGeometry(
                        cylinderRadius,
                        cylinderRadius,
                        length,
                        32
                    );

                    const cylinderMesh = new THREE.Mesh(cylinderGeo, sideRoadMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);

                    scene.add(cylinderMesh);
                    edges[start][end].mesh = cylinderMesh;
                }
            }
            updateInfo(`å·²åŠ è½½ ${processed.size} æ¡é€šé“ï¼Œæ¥¼å±‚å‚ç›´åˆ†å±‚æ˜¾ç¤º`);
        }

        
        function drawNodes() {
            for (const id in nodes) {
                const node = nodes[id];
                const pos = lonlatTo3d(node.lon, node.lat, node.alt); // yè½´ä¸ºæµ·æ‹”
                const alt = node.alt;

                // é•¿æ–¹ä½“å‡ ä½•ä½“ï¼šx/zæ°´å¹³ï¼Œyå‚ç›´ï¼ˆå¯¹åº”æ¥¼å±‚é«˜åº¦ï¼‰
                const boxGeo = new THREE.BoxGeometry(
                    CONFIG.BOX_SIZE.x,
                    CONFIG.BOX_SIZE.y,
                    CONFIG.BOX_SIZE.z
                );

                const baseColor = getColorByAlt(alt);
                const materials = {
                    default: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        transparent: false
                    }),
                    hover: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3,
                        transparent: false
                    }),
                    start: new THREE.MeshLambertMaterial({
                        color: 0x00ff00,
                        transparent: false
                    }),
                    end: new THREE.MeshLambertMaterial({
                        color: 0x0000ff,
                        transparent: false
                    })
                };

                const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                boxMesh.position.copy(pos);
                boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                scene.add(boxMesh);

                nodes[id] = {
                    ...node,
                    mesh: boxMesh,
                    materials,
                    originalScale: new THREE.Vector3(1, 1, 1)
                };
            }
        }

        function drawPath(path, index, color) {
            const pathMat = new THREE.MeshLambertMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });

            for(let i = 0; i < path.length - 1; i++) {
                const nodeId1 = path[i];
                const nodeId2 = path[i+1];
                const startPos = nodes[nodeId1].mesh.position.clone();
                const endPos = nodes[nodeId2].mesh.position.clone();

                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                const cylinderRadius = 80;
                const cylinderGeo = new THREE.CylinderGeometry(
                    cylinderRadius,
                    cylinderRadius,
                    length,
                    32
                );

                const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                cylinderMesh.position.copy(midPoint);
                cylinderMesh.lookAt(endPos);
                cylinderMesh.rotateX(Math.PI / 2);

                scene.add(cylinderMesh);
                pathMeshes.push(cylinderMesh);
            }

            const weight = calculatePathWeight(path);
            const length = calculatePathLength(path);
            pathData.push({ index, nodes: path, weight, length });

            const pathEl = document.getElementById(`path${index}`);
            pathEl.innerHTML = `
                <div style="font-weight: bold;">ç¬¬${index}æ¡æœ€çŸ­è·¯å¾„</div>
                <div>æ•™å®¤åºåˆ—ï¼š${path.join(' â†’ ')}</div>
                <div>é€šé“æ€»é•¿ï¼š${length.toFixed(2)} ç±³</div>
                <div>ç»¼åˆæƒé‡ï¼š${weight.toFixed(2)}</div>
            `;
            document.getElementById('path-detail').style.display = 'block';
        }

        // 7. è·¯å¾„ç®—æ³•ï¼ˆæ— ä¿®æ”¹ï¼‰
        function calculateEdgeWeight(startId, endId) {
            if (!edges[startId] || !edges[startId][endId]) return Infinity;
    
            const start = nodes[startId];
            const end = nodes[endId];
            const edge = edges[startId][endId];

            const x1 = start.lon * 111000;
            const y1 = start.lat * 111000;
            const x2 = end.lon * 111000;
            const y2 = end.lat * 111000;
            const geoDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

            // ========== ä»¥ä¸‹æ˜¯æ ¸å¿ƒä¿®æ”¹ï¼šæŒ‡æ•°çº§æ‹¥æŒ¤åº¦æƒ©ç½š ==========
            // 1. å¢åŠ è¾¹ç•Œå¤„ç†ï¼Œé¿å…max_cap=0æ—¶é™¤ä»¥0æŠ¥é”™
            const congestion = edge.max_cap === 0 
                ? 0 
                : edge.actual_flow / edge.max_cap;
    
            // 2. æŒ‡æ•°æƒ©ç½šæ ¸å¿ƒé€»è¾‘ï¼ˆå¯è°ƒæ•´baseå’Œexponentæ§åˆ¶æƒ©ç½šå¼ºåº¦ï¼‰
            const base = 2; // åº•æ•°ï¼ˆè¶Šå¤§ï¼Œæƒ©ç½šå¢é•¿è¶Šå¿«ï¼‰
            const exponent = 3; // æŒ‡æ•°ï¼ˆè¶Šå¤§ï¼Œé«˜æ‹¥æŒ¤åº¦æƒ©ç½šè¶Šé‡ï¼‰
            let congestionRatio;

            if (congestion <= 1.0) {
                // æ‹¥æŒ¤åº¦â‰¤1æ—¶ï¼šæŒ‡æ•°å¢é•¿ï¼ˆæ¯”å¦‚congestion=0.8â†’2^(3*0.8)=2^2.4â‰ˆ5.27ï¼›congestion=0.9â†’2^2.7â‰ˆ6.49ï¼‰
                congestionRatio = Math.pow(base, exponent * congestion);
            } else {
                // æ‹¥æŒ¤åº¦>1æ—¶ï¼šåœ¨æŒ‡æ•°åŸºç¡€ä¸Šå åŠ é¢å¤–æƒ©ç½šï¼ˆæ¯”åŸçº¿æ€§æ›´é‡ï¼‰
                const overCongestion = congestion - 1.0;
                congestionRatio = Math.pow(base, exponent * 1.0) * (1 + overCongestion * 5); // 5æ˜¯è¶…è´Ÿè½½æƒ©ç½šç³»æ•°ï¼Œå¯è°ƒ
            }
    
            const roadCoeff = edge.road_type === 'main' ? 0.9 : 1.2;

            const altDiff = end.alt - start.alt;
            const altPenalty = altDiff > 0 ? altDiff * 0.001 : Math.abs(altDiff) * 0.0012;

            return congestionRatio * geoDist * roadCoeff + altPenalty;
        }

        function calculatePathWeight(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                total += calculateEdgeWeight(path[i], path[i + 1]);
            }
            return total;
        }

        function calculatePathLength(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const start = nodes[path[i]];
                const end = nodes[path[i + 1]];
                        // å¹³é¢è·ç¦»ï¼šç»çº¬åº¦è½¬ç±³åçš„æ°´å¹³è·ç¦»
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                const planeDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        
                        // æµ·æ‹”è·ç¦»ï¼šæ¥¼å±‚é«˜åº¦å·®çš„ç»å¯¹å€¼
                const altDiff = end.alt - start.alt;
                const altDist = Math.abs(altDiff);
                        
                        // 3Dç©ºé—´è·ç¦»ï¼šå¹³é¢+æµ·æ‹”çš„å‹¾è‚¡å®šç†è®¡ç®—
                const spaceDist = Math.sqrt(Math.pow(planeDist, 2) + Math.pow(altDist, 2));
                        
                total += spaceDist;
            }
            return total;
        }

        function dijkstra(startId, endId) {
            const distances = {};
            const predecessors = {};
            const unvisited = new Set(Object.keys(nodes));

            Object.keys(nodes).forEach(id => {
                distances[id] = Infinity;
                predecessors[id] = null;
            });
            distances[startId] = 0;

            while (unvisited.size > 0) {
                let currentId = null;
                let minDist = Infinity;
                for (const id of unvisited) {
                    if (distances[id] < minDist) {
                        minDist = distances[id];
                        currentId = id;
                    }
                }

                if (currentId === null || currentId === endId) break;
                unvisited.delete(currentId);

                for (const neighborId in edges[currentId]) {
                    if (!unvisited.has(neighborId)) continue;
                    const newDist = distances[currentId] + calculateEdgeWeight(currentId, neighborId);
                    if (newDist < distances[neighborId]) {
                        distances[neighborId] = newDist;
                        predecessors[neighborId] = currentId;
                    }
                }
            }

            const path = [];
            let current = endId;
            while (current !== null) {
                path.push(current);
                current = predecessors[current];
            }
            path.reverse();

            return path[0] === startId ? path : null;
        }


        function yenKShortestPaths(startId, endId, K) {
            const kPaths = [];
            // 1. æ‰¾ç¬¬ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼ˆDijkstraï¼‰
            const firstPath = dijkstra(startId, endId);
            if (!firstPath) return [];
            kPaths.push(firstPath);

            // 2. è¿­ä»£æ‰¾ç¬¬2~Kæ¡è·¯å¾„
            for (let k = 1; k < K; k++) {
                const prevPath = kPaths[k-1];
                const candidates = [];

                // éå†å‰ä¸€æ¡è·¯å¾„çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œä½œä¸ºâ€œåç¦»ç‚¹â€
                for (let i = 0; i < prevPath.length - 1; i++) {
                    const spurNode = prevPath[i];
                    const rootPath = prevPath.slice(0, i+1);

                    // ä¸´æ—¶åˆ é™¤â€œåç¦»ç‚¹ä¹‹å‰çš„è¾¹â€ï¼Œé¿å…é‡å¤è·¯å¾„
                    const removedEdges = new Map();
                    kPaths.forEach(path => {
                        if (path.slice(0, i+1).join(',') === rootPath.join(',')) {
                            const edgeKey = `${path[i]}-${path[i+1]}`;
                            if (edges[path[i]]?.[path[i+1]]) {
                                removedEdges.set(edgeKey, edges[path[i]][path[i+1]]);
                                delete edges[path[i]][path[i+1]];
                            }
                        }
                    });

                    // æ‰¾ä»â€œåç¦»ç‚¹â€åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼ˆspur pathï¼‰
                    const spurPath = dijkstra(spurNode, endId);
                    if (spurPath) {
                        const newPath = [...rootPath.slice(0, -1), ...spurPath];
                        // ===== æ–°å¢ï¼šè·¯å¾„å»é‡ï¼ˆå…³é”®ï¼ï¼‰=====
                        // æ£€æŸ¥æ–°è·¯å¾„æ˜¯å¦å’Œå·²æœ‰çš„è·¯å¾„å®Œå…¨é‡å¤
                        const isDuplicate = kPaths.some(existPath => 
                            existPath.length === newPath.length && 
                            existPath.join(',') === newPath.join(',')
                        );
                        if (!isDuplicate) {
                            candidates.push({
                                path: newPath,
                                weight: calculatePathWeight(newPath)
                            });
                        }
                        // =====================================
                    }

                    // æ¢å¤åˆ é™¤çš„è¾¹
                    removedEdges.forEach((edge, edgeKey) => {
                        const [u, v] = edgeKey.split('-');
                        if (!edges[u]) edges[u] = {};
                        edges[u][v] = edge;
                    });
                }

                // æ²¡æœ‰å€™é€‰è·¯å¾„ï¼Œæå‰ç»“æŸ
                if (candidates.length === 0) break;

                // é€‰å€™é€‰è·¯å¾„ä¸­æƒé‡æœ€å°çš„ï¼ŒåŠ å…¥kPaths
                candidates.sort((a, b) => a.weight - b.weight);
                kPaths.push(candidates[0].path);
            }

            return kPaths;
        }

        // 8. äº¤äº’é€»è¾‘
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNodeId = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                Object.values(nodes).map(n => n.mesh),
                false
            );

            if (hoveredNodeId && !selectedNodes.includes(hoveredNodeId)) {
                const prevNode = nodes[hoveredNodeId];
                prevNode.mesh.material = prevNode.materials.default;
                prevNode.mesh.scale.copy(prevNode.originalScale);
                hoveredNodeId = null;
            }

            if (intersects.length > 0) {
                const targetNode = intersects[0].object;
                const nodeId = targetNode.userData.id;
                if (!selectedNodes.includes(nodeId)) {
                    hoveredNodeId = nodeId;
                    const currNode = nodes[nodeId];
                    currNode.mesh.material = currNode.materials.hover;
                    currNode.mesh.scale.set(1.2, 1.2, 1.2);
                }
            }
        }

        function onMouseClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                Object.values(nodes).map(n => n.mesh),
                false
            );

            if (intersects.length === 0) {
                updateInfo("è¯·ç‚¹å‡»æœ‰æ•ˆæ•™å®¤ï¼ˆç°è‰²é•¿æ–¹ä½“ï¼‰", true);
                return;
            }

            const targetNode = intersects[0].object;
            const nodeId = targetNode.userData.id;

            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];
            pathData = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';

            if (selectedNodes.length === 0) {
                selectedNodes.push(nodeId);
                nodes[nodeId].mesh.material = nodes[nodeId].materials.start;
                nodes[nodeId].mesh.scale.copy(nodes[nodeId].originalScale);
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            } else if (selectedNodes.length === 1) {
                if (nodeId === selectedNodes[0]) {
                    updateInfo("âŒ ä¸èƒ½é€‰æ‹©åŒä¸€é•¿æ–¹ä½“ä½œä¸ºç»ˆç‚¹ï¼Œè¯·é‡æ–°ç‚¹å‡»", true);
                    return;
                }

                selectedNodes.push(nodeId);
                nodes[nodeId].mesh.material = nodes[nodeId].materials.end;
                nodes[nodeId].mesh.scale.copy(nodes[nodeId].originalScale);
                updateInfo(`ğŸ” æ­£åœ¨è®¡ç®—è·¯å¾„ï¼š${selectedNodes[0]} â†’ ${nodeId}`);

                const kPaths = yenKShortestPaths(selectedNodes[0], nodeId, CONFIG.K);
                if (kPaths.length === 0) {
                    updateInfo(`âŒ æœªæ‰¾åˆ°ä» ${selectedNodes[0]} åˆ° ${nodeId} çš„è·¯å¾„`, true);
                } else {
                    updateInfo(`âœ… æ‰¾åˆ° ${kPaths.length} æ¡è·¯å¾„ï¼Œç‚¹å‡»ç©ºç™½å¤„é‡æ–°é€‰æ‹©`);
                    const pathColors = [0xff0000, 0x8800ff];
                    kPaths.forEach((path, idx) => {
                        drawPath(path, idx + 1, pathColors[idx]);
                    });
                }
            } else {
                selectedNodes.forEach(id => {
                    nodes[id].mesh.material = nodes[id].materials.default;
                    nodes[id].mesh.scale.copy(nodes[id].originalScale);
                });
                selectedNodes = [nodeId];
                nodes[nodeId].mesh.material = nodes[nodeId].materials.start;
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            }
        }

        // 9. æ•°æ®åŠ è½½
        function loadData() {
            fetch('path_data.json')
                .then(response => {
                    if (!response.ok) throw new Error(`æ•°æ®åŠ è½½å¤±è´¥ï¼ˆ${response.status}ï¼‰`);
                    return response.json();
                })
                .then(data => {
                    minLon = data.min_lon;
                    minLat = data.min_lat;
                    nodes = data.nodes;
                    edges = data.edges;

                    if (!nodes || Object.keys(nodes).length === 0) throw new Error("èŠ‚ç‚¹æ•°æ®ä¸ºç©º");
                    if (!edges || Object.keys(edges).length === 0) throw new Error("è¾¹æ•°æ®ä¸ºç©º");

                    drawEdges();
                    drawNodes();
                })
                .catch(error => {
                    updateInfo(`âš ï¸ åˆå§‹åŒ–å¤±è´¥ï¼š${error.message}`, true);
                    if (error.message.includes('404')) {
                        updateInfo(`âš ï¸ æœªæ‰¾åˆ°path_data.jsonï¼ˆè¯·ç¡®ä¿ä¸index.htmlåŒç›®å½•ï¼‰`, true);
                    } else if (error.message.includes('JSON')) {
                        updateInfo(`âš ï¸ path_data.jsonæ ¼å¼é”™è¯¯ï¼ˆé‡æ–°è¿è¡ŒPythonå¯¼å‡ºï¼‰`, true);
                    }
                });
        }

        // 10. äº‹ä»¶ä¸åŠ¨ç”»
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        loadData();
        animate();
    </script>
</body>

</html>


















