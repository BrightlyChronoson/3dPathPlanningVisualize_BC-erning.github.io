<!DOCTYPE html>
<html>
<head>
    <title>3D路径规划系统</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; top: 10px; left: 10px; 
            background: rgba(255,255,255,0.9); padding: 12px 15px; 
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px; color: #333; z-index: 100;
        }
        #mode-panel {
            position: absolute; top: 10px; left: 280px;
            background: rgba(255,255,255,0.9); padding: 10px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
            cursor: move; 
        }
        .mode-btn {
            padding: 6px 12px; margin: 0 5px;
            border: 1px solid #ccc; border-radius: 4px;
            background: #f5f5f5; cursor: pointer; font-size: 13px;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: #007bff; color: white; border-color: #007bff;
        }
        .mode-btn:hover { background: #e9ecef; }
        .mode-btn.active:hover { background: #0069d9; }
        
        /* 情境切换面板样式 */
        #scenario-panel {
            position: absolute; top: 10px; left: 480px;
            background: rgba(255,255,255,0.9); padding: 10px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
            cursor: move; 
        }
        .scenario-btn {
            padding: 6px 12px; margin: 0 5px;
            border: 1px solid #ccc; border-radius: 4px;
            background: #f5f5f5; cursor: pointer; font-size: 13px;
            transition: all 0.2s;
        }
        .scenario-btn.active {
            background: #28a745; color: white; border-color: #28a745;
        }
        .scenario-btn:hover { background: #e9ecef; }
        .scenario-btn.active:hover { background: #218838; }
        
        #path-detail {
            position: absolute; top: 70px; left: 10px;
            background: rgba(255,255,255,0.9); padding: 12px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px; color: #333; display: none; z-index: 100;
            cursor: move; 
        }
        #search-panel {
            cursor: move !important; /* 覆盖内联样式 */
        }
        .legend {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255,255,255,0.9); padding: 12px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px; color: #333; z-index: 100;
        }
        .legend-item {
            display: flex; align-items: center; margin: 6px 0;
        }
        .legend-color {
            width: 16px; height: 16px; margin-right: 8px; border-radius: 3px;
        }
        .error-tip { color: #dc3545; font-weight: bold; }
        .css2d-label {
            transition: transform 0.2s ease;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>
    <div id="info-panel">点击第一个长方体作为起点（绿色），第二个作为终点（蓝色）</div>
    <div id="mode-panel">
        <span style="font-size:13px; font-weight:bold; margin-right:8px;">选择模式：</span>
        <button class="mode-btn active" data-mode="teaching">教学楼模式</button>
        <button class="mode-btn" data-mode="campus">校园模式</button>
    </div>
    <!-- 情境切换面板 -->
    <div id="scenario-panel">
        <span style="font-size:13px; font-weight:bold; margin-right:8px;">选择情境：</span>
        <button class="scenario-btn active" data-scenario="01">情境1</button>
        <button class="scenario-btn" data-scenario="02">情境2</button>
        <button class="scenario-btn" data-scenario="03">情境3</button>
    </div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">路径详情</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">图例</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span id="legend-node-text">教室</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>悬停目标</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>起点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>终点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #006600;"></div>
            <span>连接通道</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ffff;"></div>
            <span>第1条最短路径</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #7c16f5;"></div>
            <span>第2条最短路径</span>
        </div>
    </div>

    <div id="search-panel" style="position: absolute; top: 220px; left: 10px; background: rgba(255,255,255,0.9); padding: 12px 15px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 100;">
        <div style="font-weight: bold; margin-bottom: 8px; font-size: 13px;">节点查找</div>
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <div style="flex: 1;">
                <label for="start-node-input" style="font-size: 12px; color: #666;">起点：</label>
                <input type="text" id="start-node-input" placeholder="输入节点名" style="width: 100%; padding: 4px 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-top: 4px;">
            </div>
            <div style="flex: 1;">
                <label for="end-node-input" style="font-size: 12px; color: #666;">终点：</label>
                <input type="text" id="end-node-input" placeholder="输入节点名" style="width: 100%; padding: 4px 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-top: 4px;">
            </div>
        </div>
        <button id="search-path-btn" style="padding: 5px 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">计算路径</button>
        <div id="search-tip" style="margin-top: 6px; font-size: 12px; color: #dc3545; display: none;"></div>
    </div>
    
    <script>

        // ===================== 全局基础层（共享） =====================
        let cameraPosition = { x: 20000, y: 15000, z: 20000 }; 

        // ===================== 通用节流函数 =====================
        function throttle(func, delay) {
            let lastExecuteTime = 0;
            let timeoutId = null;
            return function(...args) {
                const now = Date.now();
                if (now - lastExecuteTime >= delay) {
                    func.apply(this, args);
                    lastExecuteTime = now;
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                        lastExecuteTime = Date.now();
                    }, delay);
                }
            };
        }

        // ===================== 相机控制配置（旋转+移动） =====================
        const CAMERA_CONFIG = {
            rotateSpeed: 0.04,    // 平缓的旋转速度
            maxPolarAngle: Math.PI / 2 - 0.1, // 防止相机翻倒
            minPolarAngle: 0.1,
            throttleDelay: 10     // 长按触发间隔
        };

        const CAMERA_MOVE_CONFIG = {
            moveSpeed: 50,       // 移动速度（单位：像素/帧）
            throttleDelay: 10     // 移动节流间隔
        };

        // 存储按键状态
        const pressedKeys = {};
        
        // Three.js核心对象
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // 全局状态
        let currentModeInstance = null;
        let currentScenario = '01'; // 默认情境1
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNodeId = null;
        let labelRenderer;
        let clouds = []; // 全局白云数组，用于动画更新

        // ===================== 面板拖拽函数（优化：添加边界限制） =====================
        function makePanelDraggable(panelElement) {
            if (!panelElement) return;
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            panelElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = parseInt(window.getComputedStyle(panelElement).left) || 0;
                initialTop = parseInt(window.getComputedStyle(panelElement).top) || 0;
                panelElement.style.userSelect = 'none';
                panelElement.style.zIndex = 200;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const offsetX = e.clientX - startX;
                const offsetY = e.clientY - startY;
                // 计算新位置并添加边界限制
                let newLeft = initialLeft + offsetX;
                let newTop = initialTop + offsetY;
                
                // 限制面板不超出可视区域
                const panelWidth = panelElement.offsetWidth;
                const panelHeight = panelElement.offsetHeight;
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - panelWidth - 10));
                newTop = Math.max(0, Math.min(newTop, window.innerHeight - panelHeight - 10));

                panelElement.style.left = `${newLeft}px`;
                panelElement.style.top = `${newTop}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panelElement.style.userSelect = '';
                    panelElement.style.zIndex = 100;
                }
            });
        }
        
        // ===================== 相机旋转函数（仅保留旋转） =====================
        function rotateCamera(direction) {
            if (!controls) return;
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(new THREE.Vector3().subVectors(camera.position, controls.target));

            // 左右旋转（绕Y轴）
            if (direction === 'left') {
                spherical.theta += CAMERA_CONFIG.rotateSpeed;
            } else if (direction === 'right') {
                spherical.theta -= CAMERA_CONFIG.rotateSpeed;
            }

            // 上下旋转（绕X轴，限制角度）
            if (direction === 'up') {
                spherical.phi = Math.max(CAMERA_CONFIG.minPolarAngle, spherical.phi - CAMERA_CONFIG.rotateSpeed);
            } else if (direction === 'down') {
                spherical.phi = Math.min(CAMERA_CONFIG.maxPolarAngle, spherical.phi + CAMERA_CONFIG.rotateSpeed);
            }

            // 应用新位置
            camera.position.setFromSpherical(spherical).add(controls.target);
            camera.lookAt(controls.target);
            controls.update();
        }

        // 节流包装旋转函数
        const throttledRotate = throttle(rotateCamera, CAMERA_CONFIG.throttleDelay);

        // ===================== 镜头移动函数 =====================
        function moveCamera(direction) {
            if (!controls) return;
            
            // 创建相机方向向量（仅沿X/Z轴移动，保持Y轴高度不变）
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; // 取消垂直方向移动，避免镜头上下飘
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(camera.up, forward).normalize();

            // 根据按键方向移动
            switch(direction) {
                case 'forward': // W键：向前
                    camera.position.add(forward.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    controls.target.add(forward.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    break;
                case 'backward': // S键：向后
                    camera.position.sub(forward.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    controls.target.sub(forward.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    break;
                case 'left': // A键：向左
                    camera.position.add(right.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    controls.target.add(right.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    break;
                case 'right': // D键：向右
                    camera.position.sub(right.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    controls.target.sub(right.multiplyScalar(CAMERA_MOVE_CONFIG.moveSpeed));
                    break;
            }
            
            controls.update();
        }

        // 节流包装移动函数
        const throttledMove = throttle(moveCamera, CAMERA_MOVE_CONFIG.throttleDelay);

        // ===================== 全局工具函数 =====================
        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="error-tip">${text}</span>` : text;
        }

        function clearSelectedPath() {
            if (!currentModeInstance) return;

            // 恢复节点材质和缩放
            currentModeInstance.selectedNodes.forEach(id => {
                const node = currentModeInstance.nodes[id];
                if (node) {
                    node.mesh.material = node.materials.default;
                    node.mesh.scale.copy(node.originalScale);
                }
            });

            // 移除路径网格
            currentModeInstance.pathMeshes.forEach(mesh => scene.remove(mesh));
            currentModeInstance.pathMeshes = [];

            // 重置状态
            currentModeInstance.selectedNodes = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';
            hoveredNodeId = null;
            updateInfo(`点击第一个长方体作为起点（绿色），第二个作为终点（蓝色）`);
        }

        // ===================== 全局树木创建函数（修复作用域问题） =====================
        function createTree(x, z, height = 8000, trunkRadius = 200, crownRadius = 1500) {
            // 1. 树干（圆柱体）
            const trunkGeo = new THREE.CylinderGeometry(trunkRadius, trunkRadius, height * 0.7, 16);
            const trunkMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513, roughness: 0.8, metalness: 0.1 
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x, height * 0.35, z); // 树干底部贴地（y轴居中）
            trunk.castShadow = true;
            // 新增：给树干添加标记
            trunk.userData = { isTree: true, type: 'trunk' };
            scene.add(trunk);

            // 2. 树冠（圆锥体）
            const crownGeo = new THREE.ConeGeometry(crownRadius, height * 0.8, 16);
            const crownMat = new THREE.MeshStandardMaterial({ 
                color: 0x228B22, roughness: 0.7, metalness: 0.05 
            });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.set(x, height * 0.7 + height * 0.35, z); // 树冠接树干顶部
            crown.castShadow = true;
            // 新增：给树冠添加标记
            crown.userData = { isTree: true, type: 'crown' };
            scene.add(crown);
        }

        // ===================== 初始化全局Three.js环境 =====================
        function initGlobalScene() {
            // 天空背景
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 256; skyCanvas.height = 256;
            const skyCtx = skyCanvas.getContext('2d');
            const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 256);
            skyGrad.addColorStop(0, '#E0F7FF');
            skyGrad.addColorStop(1, '#87CEEB');
            skyCtx.fillStyle = skyGrad;
            skyCtx.fillRect(0, 0, 256, 256);
            scene.background = new THREE.CanvasTexture(skyCanvas);

            // 相机配置
            camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
            camera.lookAt(new THREE.Vector3(0, 70, 0));

            // 渲染器配置
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 标签渲染器
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);
            
            // 控制器配置（关闭自带键盘控制）
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 5000;
            controls.maxDistance = 100000;
            controls.target.set(0, 70, 0);
            controls.maxPolarAngle = Math.PI / 2;
            controls.enableKeys = false; // 关闭OrbitControls自带键盘控制

            // 全局光照
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50000, 80000, 50000);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 200000;
            dirLight.shadow.camera.left = -50000;
            dirLight.shadow.camera.right = 50000;
            dirLight.shadow.camera.top = 50000;
            dirLight.shadow.camera.bottom = -50000;
            scene.add(dirLight);

            // ===================== 新增：天空飘动的白云 =====================
            function createCloud(x, y, z, scale = 1.3) {
                const cloudGroup = new THREE.Group();
                const cloudLayerCount = 2 + Math.floor(Math.random() * 4); // 2~5层（减少层数避免堆墙）
        
                // 生成更柔和的云纹理（用径向渐变+模糊）
                function createCloudTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
            
                    // 径向渐变：中心白→边缘透明
                    const gradient = ctx.createRadialGradient(
                        256, 256, 0,
                        256, 256, 256
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
                    // 多组随机椭圆（避免圆形规整感）
                    ctx.fillStyle = gradient;
                    for (let j = 0; j < 8; j++) {
                        const w = 100 + Math.random() * 200;
                        const h = 80 + Math.random() * 150;
                        const x = 256 + (Math.random() - 0.5) * 200;
                        const y = 256 + (Math.random() - 0.5) * 150;
                
                        ctx.beginPath();
                        ctx.ellipse(x, y, w, h, Math.random() * Math.PI, 0, Math.PI * 2);
                        ctx.fill();
                    }
            
                    return new THREE.CanvasTexture(canvas);
                }

                for (let i = 0; i < cloudLayerCount; i++) {
                    // 云材质改用MeshBasicMaterial（不受光照影响，稳定显示白色）
                    const cloudMat = new THREE.MeshBasicMaterial({
                        map: createCloudTexture(),
                        transparent: true,
                        opacity: 0.4 + Math.random() * 0.3,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });

                    // 每层云大小/形状随机（避免统一）
                    const cloudGeo = new THREE.PlaneGeometry(
                        10000 * scale + Math.random() * 12000,
                        8000 * scale + Math.random() * 10000,
                        1
                    );

                    const cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
                    // 更大的随机偏移（避免堆叠成平面）
                    cloudMesh.position.set(
                        (Math.random() - 0.5) * 15000 * scale,
                        (Math.random() - 0.5) * 12000 * scale,
                        (Math.random() - 0.5) * 8000 * scale
                    );
                    cloudMesh.rotation.set(
                        Math.random() * 0.5,
                        Math.random() * Math.PI,
                        Math.random() * 0.3
                    ); // 多角度旋转，不只是平面
            
                    cloudGroup.add(cloudMesh);
                }

                // 云的位置更分散（扩大范围）
                cloudGroup.position.set(
                    x,
                    y || (25000 + Math.random() * 40000), // 高度范围更大
                    z
                );

                // 移动速度更随机（避免同步）
                cloudGroup.userData = {
                    speedX: (Math.random() - 0.5) * 15 + 2,
                    speedZ: (Math.random() - 0.5) * 12 + 1,
                    maxX: 200000,
                    minX: -200000,
                    maxZ: 200000,
                    minZ: -200000
                };

                scene.add(cloudGroup);
                clouds.push(cloudGroup);
            }

            // 云数量减少+分布更散（8~12朵）
            const cloudCount = 15 + Math.floor(Math.random() * 5);
            for (let i = 0; i < cloudCount; i++) {
                createCloud(
                    (Math.random() - 0.5) * 300000, // X范围扩大到±15万
                    null,
                    (Math.random() - 0.5) * 300000  // Z范围扩大到±15万
                );
            }

            
            // 全局地板
            const floorGeometry = new THREE.PlaneGeometry(300000, 300000);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xf0f0f0, roughness: 0.8, metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);
            
            // 动画循环（仅处理旋转）
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
                labelRenderer.render(scene, camera);

                // 标签大小随相机距离调整
                const distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
                const scale = Math.max(0.5, 2 - distance / 50000);
                document.querySelectorAll('.css2d-label').forEach(el => {
                    el.style.transform = `${el.style.transform} scale(${scale})`;
                    el.style.transformOrigin = 'center';
                });

                // 按键处理（旋转+移动）
                if (pressedKeys['ArrowUp']) throttledRotate('up');
                if (pressedKeys['ArrowDown']) throttledRotate('down');
                if (pressedKeys['ArrowLeft']) throttledRotate('left');
                if (pressedKeys['ArrowRight']) throttledRotate('right');

                // WSAD键：镜头前后/左右移动
                if (pressedKeys['w'] || pressedKeys['W']) throttledMove('forward');
                if (pressedKeys['s'] || pressedKeys['S']) throttledMove('backward');
                if (pressedKeys['a'] || pressedKeys['A']) throttledMove('left');
                if (pressedKeys['d'] || pressedKeys['D']) throttledMove('right');

                // 白云飘动动画
                clouds.forEach(cloud => {
                    // 更新云的位置
                    cloud.position.x += cloud.userData.speedX;
                    cloud.position.z += cloud.userData.speedZ;
            
                    // 超出边界后重置位置（循环飘动）
                    if (cloud.position.x > cloud.userData.maxX) {
                        cloud.position.x = cloud.userData.minX;
                    } else if (cloud.position.x < cloud.userData.minX) {
                        cloud.position.x = cloud.userData.maxX;
                    }
                    if (cloud.position.z > cloud.userData.maxZ) {
                        cloud.position.z = cloud.userData.minZ;
                    } else if (cloud.position.z < cloud.userData.minZ) {
                        cloud.position.z = cloud.userData.maxZ;
                    }
            
                    // 轻微旋转，模拟云的变形
                    cloud.rotation.y += 0.001 * (Math.random() - 0.5);
                });
            }

            animate();
        }

        // ===================== 模式基类 =====================
        class BaseMode {
            constructor(modeName, config) {
                this.modeName = modeName;
                this.config = config;
                // 动态拼接数据文件名（模式+情境）
                this.dataFile = `${modeName === 'teaching' ? 'path_data_6J' : 'path_data_campus'}_${currentScenario}.json`;

                // 模式私有资源
                this.nodes = {};
                this.edges = {};
                this.selectedNodes = [];
                this.pathMeshes = [];
                this.nodeMeshes = [];
                this.edgeMeshes = [];
                this.minLon = 0;
                this.minLat = 0;
            }

            // 坐标转换
            lonlatTo3d(lon, lat, alt) {
                const x = (lon - this.minLon) * this.config.SCALE + this.config.X_OFFSET;
                const y = alt * this.config.ALTITUDE_SCALE + this.config.Y_OFFSET;
                const z = (this.minLat - lat) * this.config.SCALE + this.config.Z_OFFSET;
                return new THREE.Vector3(x, y, z);
            }

            // 调整相机位置
            adjustCamera() {
                if (this.modeName === 'campus') {
                    cameraPosition = { x: 80000, y: 40000, z: 80000 };
                } else {
                    cameraPosition = { x: 20000, y: 15000, z: 20000 };
                }
                camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
                camera.lookAt(new THREE.Vector3(0, 1000, 0));
                controls.target.set(0, 1000, 0);
            }

            // 销毁当前模式资源
            destroy() {
                // 移除3D元素
                this.pathMeshes.forEach(mesh => scene.remove(mesh));
                this.nodeMeshes.forEach(mesh => scene.remove(mesh));
                this.edgeMeshes.forEach(mesh => scene.remove(mesh));

                if (labelRenderer) {
                    labelRenderer.domElement.innerHTML = '';
                }

                // 收集所有带树木标记的元素（避免遍历中修改数组导致漏删）
                const treeMeshes = [];
                scene.children.forEach(child => {
                    if (child.userData && child.userData.isTree) {
                        treeMeshes.push(child);
                    }
                });
                // 批量删除树木（树干+树冠），并释放内存
                treeMeshes.forEach(mesh => {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
        
                // 重置状态
                this.nodes = {};
                this.edges = {};
                this.selectedNodes = [];
                this.pathMeshes = [];
                this.nodeMeshes = [];
                this.edgeMeshes = [];
                this.minLon = 0;
                this.minLat = 0;
                document.getElementById('path-detail').style.display = 'none';
                document.getElementById('path1').innerHTML = '';
                document.getElementById('path2').innerHTML = '';
                hoveredNodeId = null;
            }

            // 加载模式数据
            loadData() {
                updateInfo(`正在加载${this.modeName === 'teaching' ? '教学楼' : '校园'}模式-情境${currentScenario.replace('0', '')}数据...`);
                fetch(this.dataFile)
                    .then(response => {
                        if (!response.ok) throw new Error(`数据加载失败（${response.status}）`);
                        return response.json();
                    })
                    .then(data => {
                        this.minLon = data.min_lon;
                        this.minLat = data.min_lat;
                        this.nodes = data.nodes;
                        this.edges = data.edges;
                        if (!this.nodes || Object.keys(this.nodes).length === 0) throw new Error("节点数据为空");
                        if (!this.edges || Object.keys(this.edges).length === 0) throw new Error("边数据为空");
                        this.drawEdges();
                        this.drawNodes();
                        this.adjustCamera();
                        document.getElementById('legend-node-text').innerText = this.modeName === 'teaching' ? '教室' : '建筑';
                        updateInfo(`✅ ${this.modeName === 'teaching' ? '教学楼' : '校园'}模式-情境${currentScenario.replace('0', '')}加载完成，点击选择起点`);
                    })
                    .catch(error => {
                        updateInfo(`⚠️ 加载失败：${error.message}`, true);
                        if (error.message.includes('404')) {
                            updateInfo(`⚠️ 未找到${this.dataFile}（请确保与index.html同目录）`, true);
                        }
                    });
            }

            // 绘制边
            drawEdges() {
                const processed = new Set();
                for (const start in this.edges) {
                    for (const end in this.edges[start]) {
                        const key = `${start}-${end}`;
                        const reverseKey = `${end}-${start}`;
                        if (processed.has(key) || processed.has(reverseKey)) continue;
                        processed.add(key);
                        if (!this.nodes[start] || !this.nodes[end]) continue;

                        // 拥挤度颜色
                        const edgeData = this.edges[start][end];
                        const crowd = edgeData.max_cap === 0 ? 0 : Math.min(Math.max(edgeData.actual_flow / edgeData.max_cap, 0), 1);
                        let edgeColor = crowd < 0.5 ? 0x006600 : (crowd <= 0.8 ? 0xffff00 : 0xff0000);

                        // 材质
                        const sideRoadMat = new THREE.MeshStandardMaterial({
                            color: edgeColor, roughness: 0.7, metalness: 0.1,
                            transparent: true, opacity: 0.8
                        });

                        // 坐标计算
                        const startPos = this.lonlatTo3d(this.nodes[start].lon, this.nodes[start].lat, this.nodes[start].alt);
                        const endPos = this.lonlatTo3d(this.nodes[end].lon, this.nodes[end].lat, this.nodes[end].alt);
                        const direction = new THREE.Vector3().subVectors(endPos, startPos);
                        const length = direction.length();
                        const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                        // 通道几何体
                        const cylinderGeo = new THREE.CylinderGeometry(
                            this.config.EDGE_RADIUS,
                            this.config.EDGE_RADIUS,
                            length,
                            32
                        );

                        const cylinderMesh = new THREE.Mesh(cylinderGeo, sideRoadMat);
                        cylinderMesh.position.copy(midPoint);
                        cylinderMesh.lookAt(endPos);
                        cylinderMesh.rotateX(Math.PI / 2);
                        scene.add(cylinderMesh);
                        this.edges[start][end].mesh = cylinderMesh;
                        this.edgeMeshes.push(cylinderMesh);
                    }
                }
            }

            // 绘制节点
            drawNodes() {
                for (const id in this.nodes) {
                    const node = this.nodes[id];
                    const pos = this.lonlatTo3d(node.lon, node.lat, node.alt);
                    const alt = node.alt;

                    // 节点几何体
                    const boxGeo = new THREE.BoxGeometry(
                        this.config.BOX_SIZE.x,
                        this.config.BOX_SIZE.y,
                        this.config.BOX_SIZE.z
                    );

                    // 材质
                    const baseColor = 0x999999;
                    const materials = {
                        default: new THREE.MeshStandardMaterial({ 
                            color: baseColor, roughness: 0.7, metalness: 0.1,
                            emissive: 0x000000, emissiveIntensity: 0
                        }),
                        hover: new THREE.MeshStandardMaterial({ 
                            color: baseColor, roughness: 0.7, metalness: 0.1,
                            emissive: 0xffff00, emissiveIntensity: 0.5
                        }),
                        start: new THREE.MeshStandardMaterial({ 
                            color: 0x4CAF50, roughness: 0.7, metalness: 0.2,
                            emissive: 0x00ff00, emissiveIntensity: 0.3
                        }),
                        end: new THREE.MeshStandardMaterial({ 
                            color: 0x0000ff, roughness: 0.7, metalness: 0.2,
                            emissive: 0x0000ff, emissiveIntensity: 0.3
                        })
                    };

                    const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                    boxMesh.position.copy(pos);
                    boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    scene.add(boxMesh);
                    this.nodeMeshes.push(boxMesh);

                    // 节点标签（优化：随机偏移+样式升级）
                    const labelDiv = document.createElement('div');
                    labelDiv.classList.add('css2d-label');
                    // 样式优化：更小字体、背景半透明、换行、阴影加深
                    labelDiv.style.cssText = `
                        font-size: 10px;
                        font-weight: bold;
                        color: ${id.includes('STAIR') || id.includes('CROSS') || id.includes('TURN') ? '#ffd070' : '#333'};
                        background: rgba(255,255,255,0.95);
                        padding: 2px 6px;
                        border-radius: 3px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        white-space: nowrap;
                        max-width: 120px;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    `;
                    labelDiv.textContent = id;

                    const label = new THREE.CSS2DObject(labelDiv);
                    // 核心修改：添加随机偏移（x/z轴），避免标签重叠
                    const randomOffsetX = (Math.random() - 0.5) * 800; // 随机左右偏移
                    const randomOffsetZ = (Math.random() - 0.5) * 800; // 随机前后偏移
                    label.position.set(
                        randomOffsetX, 
                        this.config.BOX_SIZE.y / 2 + 300, // 提高标签高度
                        randomOffsetZ
                    );
                    boxMesh.add(label);
                    
                    this.nodes[id] = {
                        ...node,
                        mesh: boxMesh,
                        materials,
                        originalScale: new THREE.Vector3(1, 1, 1)
                    };
                }
            }

            // 计算边权重（子类必须覆写）
            calculateEdgeWeight(startId, endId) {
                throw new Error("子类必须实现calculateEdgeWeight方法");
            }

            // 绘制路径
            drawPath(path, index, color) {
                const pathMat = new THREE.MeshStandardMaterial({
                    color: color, roughness: 0.7, metalness: 0.1,
                    transparent: true, opacity: 0.9
                });

                for (let i = 0; i < path.length - 1; i++) {
                    const nodeId1 = path[i];
                    const nodeId2 = path[i + 1];
                    const startPos = this.nodes[nodeId1].mesh.position.clone();
                    const endPos = this.nodes[nodeId2].mesh.position.clone();

                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                    // 路径几何体
                    const cylinderGeo = new THREE.CylinderGeometry(
                        this.config.PATH_RADIUS,
                        this.config.PATH_RADIUS,
                        length,
                        32
                    );

                    const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);
                    scene.add(cylinderMesh);
                    this.pathMeshes.push(cylinderMesh);
                }

                // 路径详情
                const weight = this.calculatePathWeight(path);
                const length = this.calculatePathLength(path);
                const pathEl = document.getElementById(`path${index}`);
                pathEl.innerHTML = `
                    <div style="font-weight: bold;">第${index}条最短路径</div>
                    <div>${this.modeName === 'teaching' ? '教室' : '建筑'}序列：${path.join(' → ')}</div>
                    <div>通道总长：${length.toFixed(2)} 米</div>
                    <div>综合权重：${weight.toFixed(2)}</div>
                `;
                document.getElementById('path-detail').style.display = 'block';
            }

            // 计算路径总权重
            calculatePathWeight(path) {
                let total = 0;
                for (let i = 0; i < path.length - 1; i++) {
                    total += this.calculateEdgeWeight(path[i], path[i + 1]);
                }
                return total;
            }

            // 计算路径长度
            calculatePathLength(path) {
                let total = 0;
                for (let i = 0; i < path.length - 1; i++) {
                    const start = this.nodes[path[i]];
                    const end = this.nodes[path[i + 1]];
                    const x1 = start.lon * 111000;
                    const y1 = start.lat * 111000;
                    const x2 = end.lon * 111000;
                    const y2 = end.lat * 111000;
                    const planeDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const altDiff = end.alt - start.alt;
                    const altDist = Math.abs(altDiff);
                    const spaceDist = Math.sqrt(Math.pow(planeDist, 2) + Math.pow(altDist, 2));
                    total += spaceDist;
                }
                return total;
            }

            // Dijkstra算法
            dijkstra(startId, endId) {
                const distances = {};
                const predecessors = {};
                const unvisited = new Set(Object.keys(this.nodes));
                Object.keys(this.nodes).forEach(id => {
                    distances[id] = Infinity;
                    predecessors[id] = null;
                });
                distances[startId] = 0;

                while (unvisited.size > 0) {
                    let currentId = null;
                    let minDist = Infinity;
                    for (const id of unvisited) {
                        if (distances[id] < minDist) {
                            minDist = distances[id];
                            currentId = id;
                        }
                    }
                    if (currentId === null || currentId === endId) break;
                    unvisited.delete(currentId);

                    for (const neighborId in this.edges[currentId]) {
                        if (!unvisited.has(neighborId)) continue;
                        const newDist = distances[currentId] + this.calculateEdgeWeight(currentId, neighborId);
                        if (newDist < distances[neighborId]) {
                            distances[neighborId] = newDist;
                            predecessors[neighborId] = currentId;
                        }
                    }
                }

                const path = [];
                let current = endId;
                while (current !== null) {
                    path.push(current);
                    current = predecessors[current];
                }
                path.reverse();
                return path[0] === startId ? path : null;
            }

            // Yen's K最短路径算法
            yenKShortestPaths(startId, endId, K) {
                const kPaths = [];
                const firstPath = this.dijkstra(startId, endId);
                if (!firstPath) return [];
                kPaths.push(firstPath);

                for (let k = 1; k < K; k++) {
                    const prevPath = kPaths[k - 1];
                    const candidates = [];

                    for (let i = 0; i < prevPath.length - 1; i++) {
                        const spurNode = prevPath[i];
                        const rootPath = prevPath.slice(0, i + 1);
                        const removedEdges = new Map();

                        kPaths.forEach(path => {
                            if (path.slice(0, i + 1).join(',') === rootPath.join(',')) {
                                const edgeKey = `${path[i]}-${path[i + 1]}`;
                                if (this.edges[path[i]]?.[path[i + 1]]) {
                                    removedEdges.set(edgeKey, this.edges[path[i]][path[i + 1]]);
                                    delete this.edges[path[i]][path[i + 1]];
                                }
                            }
                        });

                        const spurPath = this.dijkstra(spurNode, endId);
                        if (spurPath) {
                            const newPath = [...rootPath.slice(0, -1), ...spurPath];
                            const isDuplicate = kPaths.some(existPath =>
                                existPath.length === newPath.length && existPath.join(',') === newPath.join(',')
                            );
                            if (!isDuplicate) {
                                candidates.push({ path: newPath, weight: this.calculatePathWeight(newPath) });
                            }
                        }

                        // 恢复删除的边
                        removedEdges.forEach((edge, edgeKey) => {
                            const [u, v] = edgeKey.split('-');
                            if (!this.edges[u]) this.edges[u] = {};
                            this.edges[u][v] = edge;
                        });
                    }

                    if (candidates.length === 0) break;
                    candidates.sort((a, b) => a.weight - b.weight);
                    kPaths.push(candidates[0].path);
                }

                return kPaths;
            }
        }

        // ===================== 教学楼模式子类 =====================
        class TeachingMode extends BaseMode {
            constructor() {
                const config = {
                    SCALE: 50000000,
                    ALTITUDE_SCALE: 500,
                    X_OFFSET: -17000,
                    Y_OFFSET: -29000,
                    Z_OFFSET: 15000,
                    K: 2,
                    BOX_SIZE: { x: 2000, y: 500, z: 2000 },
                    EDGE_RADIUS: 80,
                    PATH_RADIUS: 80,
                    STAIR_PENALTY: true
                };
                super('teaching', config);
            }

            // 计算边权重（教学楼模式：楼梯+拥挤度）
            calculateEdgeWeight(startId, endId) {
                const edgeData = this.edges[startId][endId];
                const crowd = edgeData.max_cap === 0 ? 0 : Math.min(Math.max(edgeData.actual_flow / edgeData.max_cap, 0), 1);
                const crowdPenalty = 1 + crowd * 3;
                const baseDist = this.calculateEdgeLength(startId, endId);
                let stairPenalty = 1;

                if (this.config.STAIR_PENALTY) {
                    const startAlt = this.nodes[startId].alt;
                    const endAlt = this.nodes[endId].alt;
                    const altDiff = Math.abs(endAlt - startAlt);
                    if (altDiff > 0.1 && (startId.includes('STAIR') || endId.includes('STAIR'))) {
                        stairPenalty = 1.8;
                    }
                }

                return baseDist * crowdPenalty * stairPenalty;
            }

            // 计算边长度
            calculateEdgeLength(startId, endId) {
                const start = this.nodes[startId];
                const end = this.nodes[endId];
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                const planeDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const altDiff = end.alt - start.alt;
                const altDist = Math.abs(altDiff);
                return Math.sqrt(Math.pow(planeDist, 2) + Math.pow(altDist, 2));
            }
        }

        // ===================== 校园模式子类 =====================
        class CampusMode extends BaseMode {
            constructor() {
                const config = {
                    SCALE: 10000000,
                    ALTITUDE_SCALE: 500,
                    X_OFFSET: -40000,
                    Y_OFFSET: -25000,
                    Z_OFFSET: 50000,
                    K: 2,
                    BOX_SIZE: { x: 2000, y: 300, z: 2000 },
                    EDGE_RADIUS: 150,
                    PATH_RADIUS: 150,
                    STAIR_PENALTY: false
                };
                super('campus', config);
            }

            // 计算边权重（校园模式：仅拥挤度）
            calculateEdgeWeight(startId, endId) {
                const edgeData = this.edges[startId][endId];
                const crowd = edgeData.max_cap === 0 ? 0 : Math.min(Math.max(edgeData.actual_flow / edgeData.max_cap, 0), 1);
                const crowdPenalty = 1 + crowd * 2;
                const baseDist = this.calculateEdgeLength(startId, endId);
                return baseDist * crowdPenalty;
            }

            // 计算边长度
            calculateEdgeLength(startId, endId) {
                const start = this.nodes[startId];
                const end = this.nodes[endId];
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                const planeDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const altDiff = end.alt - start.alt;
                const altDist = Math.abs(altDiff);
                return Math.sqrt(Math.pow(planeDist, 2) + Math.pow(altDist, 2));
            }
        }

        // ===================== 模式切换逻辑 =====================
        function switchMode(modeType) {
            // 销毁当前模式资源
            if (currentModeInstance) {
                currentModeInstance.destroy();
                currentModeInstance = null;
            }

            // 更新UI状态
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn[data-mode="${modeType}"]`).classList.add('active');

            // 初始化新模式
            if (modeType === 'teaching') {
                currentModeInstance = new TeachingMode();
            } else if (modeType === 'campus') {
                currentModeInstance = new CampusMode();
            }

            // 加载模式数据
            currentModeInstance.loadData();

            // 重新生成树木
            const treeCount = 80;
            const minRadius = 50000;
            const maxRadius = 100000;
            for (let i = 0; i < treeCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const treeHeight = 5000;
                createTree(x, z, treeHeight);
            }

            updateInfo(`✅ 已切换至${modeType === 'teaching' ? '教学楼' : '校园'}模式-情境${currentScenario.replace('0', '')}`);
        }

        // ===================== 情境切换逻辑 =====================
        function switchScenario(scenarioId) {
            // 如果当前无激活模式，提示先选模式
            if (!currentModeInstance) {
                updateInfo(`请先选择模式（教学楼/校园）再切换情境`, true);
                return;
            }

            // 更新当前情境
            currentScenario = scenarioId;
            
            // 更新UI状态
            document.querySelectorAll('.scenario-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.scenario-btn[data-scenario="${scenarioId}"]`).classList.add('active');

            // 获取当前激活的模式类型（教学楼/校园）
            const currentModeType = document.querySelector('.mode-btn.active').getAttribute('data-mode');
            
            // 销毁当前模式资源，重新加载对应情境的模式
            if (currentModeInstance) {
                currentModeInstance.destroy();
                currentModeInstance = null;
            }

            // 重新初始化当前模式（自动拼接新情境的数据源）
            if (currentModeType === 'teaching') {
                currentModeInstance = new TeachingMode();
            } else if (currentModeType === 'campus') {
                currentModeInstance = new CampusMode();
            }

            // 加载新情境的数据
            currentModeInstance.loadData();

            // 重新生成树木
            const treeCount = 80;
            const minRadius = 50000;
            const maxRadius = 100000;
            for (let i = 0; i < treeCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const treeHeight = 5000;
                createTree(x, z, treeHeight);
            }

            updateInfo(`✅ 已切换至${currentModeType === 'teaching' ? '教学楼' : '校园'}模式-情境${scenarioId.replace('0', '')}`);
        }

        // ===================== 节点点击/悬停处理 =====================
        function setupNodeInteraction() {
            // 鼠标点击事件
            renderer.domElement.addEventListener('click', (e) => {
                if (!currentModeInstance || Object.keys(currentModeInstance.nodes).length === 0) return;

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(currentModeInstance.nodeMeshes);
                if (intersects.length === 0) return;
                const clickedNodeId = intersects[0].object.userData.id;

                // 处理起点/终点选择
                if (currentModeInstance.selectedNodes.length === 0) {
                    // 选择起点
                    currentModeInstance.selectedNodes.push(clickedNodeId);
                    currentModeInstance.nodes[clickedNodeId].mesh.material = currentModeInstance.nodes[clickedNodeId].materials.start;
                    currentModeInstance.nodes[clickedNodeId].mesh.scale.set(1.2, 1.2, 1.2);
                    updateInfo(`✅ 已选择起点：${clickedNodeId}，请选择终点`);
                } else if (currentModeInstance.selectedNodes.length === 1) {
                    // 选择终点
                    if (clickedNodeId === currentModeInstance.selectedNodes[0]) {
                        updateInfo(`⚠️ 起点和终点不能相同，请重新选择`, true);
                        return;
                    }
                    currentModeInstance.selectedNodes.push(clickedNodeId);
                    currentModeInstance.nodes[clickedNodeId].mesh.material = currentModeInstance.nodes[clickedNodeId].materials.end;
                    currentModeInstance.nodes[clickedNodeId].mesh.scale.set(1.2, 1.2, 1.2);
                    updateInfo(`✅ 已选择终点：${clickedNodeId}，正在计算最短路径...`);

                    // 计算K最短路径
                    const startId = currentModeInstance.selectedNodes[0];
                    const endId = currentModeInstance.selectedNodes[1];
                    const kPaths = currentModeInstance.yenKShortestPaths(startId, endId, currentModeInstance.config.K);

                    if (kPaths.length === 0) {
                        updateInfo(`⚠️ 未找到从${startId}到${endId}的路径`, true);
                        clearSelectedPath();
                        return;
                    }

                    // 绘制路径
                    currentModeInstance.pathMeshes.forEach(mesh => scene.remove(mesh));
                    currentModeInstance.pathMeshes = [];
                    kPaths.forEach((path, index) => {
                        const color = index === 0 ? 0x00ffff : 0x7c16f5;
                        currentModeInstance.drawPath(path, index + 1, color);
                    });

                    updateInfo(`✅ 路径计算完成：找到${kPaths.length}条最短路径`);
                } else {
                    // 重置选择
                    clearSelectedPath();
                    currentModeInstance.selectedNodes = [];
                    // 重新选择起点
                    currentModeInstance.selectedNodes.push(clickedNodeId);
                    currentModeInstance.nodes[clickedNodeId].mesh.material = currentModeInstance.nodes[clickedNodeId].materials.start;
                    currentModeInstance.nodes[clickedNodeId].mesh.scale.set(1.2, 1.2, 1.2);
                    updateInfo(`✅ 已重置选择，新起点：${clickedNodeId}，请选择终点`);
                }
            });

            // 鼠标悬停事件
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!currentModeInstance || Object.keys(currentModeInstance.nodes).length === 0) return;

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(currentModeInstance.nodeMeshes);
                if (intersects.length === 0) {
                    // 离开所有节点
                    if (hoveredNodeId && currentModeInstance.nodes[hoveredNodeId]) {
                        currentModeInstance.nodes[hoveredNodeId].mesh.material = currentModeInstance.nodes[hoveredNodeId].materials.default;
                        hoveredNodeId = null;
                    }
                    renderer.domElement.style.cursor = 'default';
                    return;
                }

                // 悬停在节点上
                const hoveredId = intersects[0].object.userData.id;
                if (hoveredId !== hoveredNodeId) {
                    // 恢复之前悬停的节点
                    if (hoveredNodeId && currentModeInstance.nodes[hoveredNodeId]) {
                        currentModeInstance.nodes[hoveredNodeId].mesh.material = currentModeInstance.nodes[hoveredNodeId].materials.default;
                    }
                    // 高亮当前悬停的节点
                    hoveredNodeId = hoveredId;
                    if (!currentModeInstance.selectedNodes.includes(hoveredId)) {
                        currentModeInstance.nodes[hoveredId].mesh.material = currentModeInstance.nodes[hoveredId].materials.hover;
                    }
                    renderer.domElement.style.cursor = 'pointer';
                }
            });
        }

        // ===================== 搜索面板逻辑 =====================
        function setupSearchPanel() {
            const startInput = document.getElementById('start-node-input');
            const endInput = document.getElementById('end-node-input');
            const searchBtn = document.getElementById('search-path-btn');

            // 搜索按钮点击事件
            searchBtn.addEventListener('click', () => {
                if (!currentModeInstance || Object.keys(currentModeInstance.nodes).length === 0) {
                    updateInfo(`⚠️ 请先加载模式数据再搜索路径`, true);
                    return;
                }

                const startId = startInput.value.trim().toUpperCase();
                const endId = endInput.value.trim().toUpperCase();

                // 验证输入
                if (!startId || !endId) {
                    updateInfo(`⚠️ 起点和终点不能为空`, true);
                    return;
                }
                if (!currentModeInstance.nodes[startId]) {
                    updateInfo(`⚠️ 未找到起点：${startId}`, true);
                    return;
                }
                if (!currentModeInstance.nodes[endId]) {
                    updateInfo(`⚠️ 未找到终点：${endId}`, true);
                    return;
                }
                if (startId === endId) {
                    updateInfo(`⚠️ 起点和终点不能相同`, true);
                    return;
                }

                // 重置之前的选择和路径
                clearSelectedPath();
                currentModeInstance.selectedNodes = [startId, endId];

                // 高亮起点和终点
                currentModeInstance.nodes[startId].mesh.material = currentModeInstance.nodes[startId].materials.start;
                currentModeInstance.nodes[startId].mesh.scale.set(1.2, 1.2, 1.2);
                currentModeInstance.nodes[endId].mesh.material = currentModeInstance.nodes[endId].materials.end;
                currentModeInstance.nodes[endId].mesh.scale.set(1.2, 1.2, 1.2);

                // 计算K最短路径
                updateInfo(`✅ 正在计算从${startId}到${endId}的最短路径...`);
                const kPaths = currentModeInstance.yenKShortestPaths(startId, endId, currentModeInstance.config.K);

                if (kPaths.length === 0) {
                    updateInfo(`⚠️ 未找到从${startId}到${endId}的路径`, true);
                    clearSelectedPath();
                    return;
                }

                // 绘制路径
                currentModeInstance.pathMeshes.forEach(mesh => scene.remove(mesh));
                currentModeInstance.pathMeshes = [];
                kPaths.forEach((path, index) => {
                    const color = index === 0 ? 0x00ffff : 0x7c16f5;
                    currentModeInstance.drawPath(path, index + 1, color);
                });

                updateInfo(`✅ 路径计算完成：找到${kPaths.length}条最短路径`);
            });

            // 输入框回车事件
            [startInput, endInput].forEach(input => {
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        searchBtn.click();
                    }
                });
            });
        }

        // ===================== 窗口适配 =====================
        function setupWindowResize() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ===================== 按键监听 =====================
        function setupKeyListener() {
            // 按下按键时记录状态
            window.addEventListener('keydown', (e) => {
                pressedKeys[e.key] = true;
                // 阻止方向键/WSAD的默认行为（如页面滚动）
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'W', 's', 'S', 'a', 'A', 'd', 'D'].includes(e.key)) {
                    e.preventDefault();
                }
                // ESC键重置选择
                if (e.key === 'Escape') {
                    clearSelectedPath();
                    updateInfo(`已重置选择，请重新选择起点`);
                }
            });

            // 松开按键时清除状态
            window.addEventListener('keyup', (e) => {
                pressedKeys[e.key] = false;
            });
        }

        // ===================== 初始化所有功能 =====================
        function init() {
            // 初始化全局场景
            initGlobalScene();
            
            // 设置面板拖拽
            makePanelDraggable(document.getElementById('mode-panel'));
            makePanelDraggable(document.getElementById('scenario-panel'));
            makePanelDraggable(document.getElementById('path-detail'));
            makePanelDraggable(document.getElementById('search-panel'));
            
            // 初始化默认模式（教学楼-情境1）
            currentModeInstance = new TeachingMode();
            currentModeInstance.loadData();

            // 生成初始树木
            const treeCount = 80;
            const minRadius = 50000;
            const maxRadius = 100000;
            for (let i = 0; i < treeCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const treeHeight = 5000;
                createTree(x, z, treeHeight);
            }

            // 绑定事件
            setupNodeInteraction();
            setupSearchPanel();
            setupWindowResize();
            setupKeyListener();

            // 绑定模式切换事件
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const modeType = this.getAttribute('data-mode');
                    switchMode(modeType);
                });
            });

            // 绑定情境切换事件
            document.querySelectorAll('.scenario-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const scenarioId = this.getAttribute('data-scenario');
                    switchScenario(scenarioId);
                });
            });

            updateInfo(`✅ 系统初始化完成，当前为教学楼模式-情境1，点击选择起点`);
        }

        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>


