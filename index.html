<!DOCTYPE html>
<html>
<head>
    <title>第六教学楼B区3D路径规划</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.9); 
            padding: 12px 15px; 
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px;
            color: #333;
            z-index: 100;
        }
        #path-detail {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            display: none;
            z-index: 100;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            color: #333;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .error提示 {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">点击第一个长方体作为起点（绿色），第二个作为终点（蓝色）</div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">路径详情</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">图例</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span>教室</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>悬停教室</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>起点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>终点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>通道（拥挤度 < 0.5）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffff00;"></div>
            <span>通道（0.5 ≤ 拥挤度 ≤ 0.8）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>通道（拥挤度 > 0.8）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>第1条最短路径</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>第2条最短路径</span>
        </div>
    </div>

    <script>
        // 1. 全局配置：修正坐标轴映射
        const CONFIG = {
            SCALE: 100000000,         // 坐标缩放系数（拉开水平距离）
            ALTITUDE_SCALE: 1000,
            K: 2,                 // 最短路径数量
            BOX_SIZE: { x: 2000, y: 500, z: 2000 }, // 长方体：x/z水平，y垂直（楼层高度）
            EDGE_WIDTH: 15,        // 通道宽度
            PATH_WIDTH: 20         // 路径宽度
        };
        let minLon = 0, minLat = 0;
        let nodes = {};         // 节点数据
        let edges = {};         // 边数据
        let selectedNodes = []; // 选中节点
        let pathMeshes = [];    // 路径网格
        let pathData = [];      // 路径详情

        // 2. Three.js核心对象初始化
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);

        // 相机：适配y轴为高度，设置水平视角
        const camera = new THREE.PerspectiveCamera(
            55,                  
            window.innerWidth / window.innerHeight,
            0.1,
            500000
        );
        camera.position.set(20000, 15000, 20000); // 调整为水平或稍高视角，避免从下往上看
        camera.lookAt(new THREE.Vector3(0, 70, 0)); // 看向场景中心

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 轨道控制器：限制相机角度，不允许从下方查看
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 5000;  
        controls.maxDistance = 100000;
        controls.target.set(0, 70, 0);
        controls.maxPolarAngle = Math.PI / 2; // 限制最大极角为90度（水平视角）

        // 3. 光照系统
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 0.8);
        spotLight.position.set(20000, 20000, 20000); // 斜上方光源
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.set(2048, 2048);
        spotLight.shadow.camera.near = 100;
        spotLight.shadow.camera.far = 100000;
        scene.add(spotLight);

        // 4. 辅助元素
        const gridHelper = new THREE.GridHelper(100000, 50); // 地面网格：x/z平面
        gridHelper.position.y = 0; // 网格在y=0处（底层地面）
        gridHelper.material.opacity = 0.5;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(10000); // 坐标轴：x红、y绿、z蓝
        scene.add(axesHelper);

        // 5. 工具函数：修正坐标映射（海拔→y轴）
        function lonlatTo3d(lon, lat, alt) {
            const x = (lon - minLon) * CONFIG.SCALE - 35000; // 经度→x轴（水平）
            const y = alt * CONFIG.ALTITUDE_SCALE - 60000;   // 海拔→y轴（垂直高度）
            const z = (lat - minLat) * CONFIG.SCALE - 15000; // 纬度→z轴（水平）
            return new THREE.Vector3(x, y, z);
        }

        // 统一使用灰色表示未选择的教室
        function getColorByAlt(alt) {
            return 0x999999; // 灰色
        }

        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="error提示">${text}</span>` : text;
        }

        // 6. 绘制函数（核心修改：edges根据拥挤度上色）
        function drawEdges() {
            const processed = new Set();
            for (const start in edges) {
                for (const end in edges[start]) {
                    const key = `${start}-${end}`;
                    const reverseKey = `${end}-${start}`;
                    if (processed.has(key) || processed.has(reverseKey)) continue;
                    processed.add(key);

                    if (!nodes[start] || !nodes[end]) continue;

                    // 计算拥挤度（新增逻辑）
                    const edgeData = edges[start][end];
                    const maxCap = edgeData.max_cap || 0;
                    const actualFlow = edgeData.actual_flow || 0;
                    const crowd = maxCap > 0 ? actualFlow / maxCap : 0; // 避免除零

                    // 根据拥挤度设置颜色（新增逻辑）
                    let edgeColor;
                    if (crowd < 0.5) {
                        edgeColor = 0x00ff00; // 绿色：宽松
                    } else if (crowd <= 0.8) {
                        edgeColor = 0xffff00; // 黄色：中等拥挤
                    } else {
                        edgeColor = 0xff0000; // 红色：严重拥挤
                    }

                    // 创建通道材质（仅颜色修改，其余不变）
                    const edgeMat = new THREE.MeshLambertMaterial({
                        color: edgeColor,
                        transparent: true,
                        opacity: 0.8
                    });

                    // 通道几何体（原有逻辑，无修改）
                    const startPos = lonlatTo3d(
                        nodes[start].lon,
                        nodes[start].lat,
                        nodes[start].alt
                    );
                    const endPos = lonlatTo3d(
                        nodes[end].lon,
                        nodes[end].lat,
                        nodes[end].alt
                    );
                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);
                    const cylinderRadius = 80;
                    const cylinderGeo = new THREE.CylinderGeometry(
                        cylinderRadius,
                        cylinderRadius,
                        length,
                        32
                    );
                    const cylinderMesh = new THREE.Mesh(cylinderGeo, edgeMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);

                    scene.add(cylinderMesh);
                    edges[start][end].mesh = cylinderMesh;
                }
            }
            updateInfo(`已加载 ${processed.size} 条通道，楼层垂直分层显示`);
        }

        function drawNodes() {
            for (const id in nodes) {
                const node = nodes[id];
                const pos = lonlatTo3d(node.lon, node.lat, node.alt); // y轴为海拔
                const baseColor = getColorByAlt(node.alt);

                // 长方体几何体（原有逻辑，无修改）
                const boxGeo = new THREE.BoxGeometry(
                    CONFIG.BOX_SIZE.x,
                    CONFIG.BOX_SIZE.y,
                    CONFIG.BOX_SIZE.z
                );

                // 材质定义（修复原语法错误）
                const materials = {
                    default: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        transparent: false
                    }),
                    hover: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3,
                        transparent: false
                    }),
                    start: new THREE.MeshLambertMaterial({
                        color: 0x00ff00,
                        transparent: false
                    }),
                    end: new THREE.MeshLambertMaterial({
                        color: 0x0000ff,
                        transparent: false
                    })
                };

                const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                boxMesh.position.copy(pos);
                boxMesh.userData = { id, alt: node.alt, lon: node.lon, lat: node.lat };
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                scene.add(boxMesh);

                nodes[id] = {
                    ...node,
                    mesh: boxMesh,
                    materials: materials,
                    originalScale: new THREE.Vector3(1, 1, 1)
                };
            }
        }

        // 绘制路径（原有逻辑，无修改）
        function drawPath(path, index, color) {
            const pathMat = new THREE.MeshLambertMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });

            for(let i = 0; i < path.length - 1; i++) {
                const nodeId1 = path[i];
                const nodeId2 = path[i+1];
                if (!nodes[nodeId1] || !nodes[nodeId2]) continue;

                const startPos = lonlatTo3d(nodes[nodeId1].lon, nodes[nodeId1].lat, nodes[nodeId1].alt);
                const endPos = lonlatTo3d(nodes[nodeId2].lon, nodes[nodeId2].lat, nodes[nodeId2].alt);
                
                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                const cylinderGeo = new THREE.CylinderGeometry(CONFIG.PATH_WIDTH, CONFIG.PATH_WIDTH, length, 32);
                const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                
                cylinderMesh.position.copy(midPoint);
                cylinderMesh.lookAt(endPos);
                cylinderMesh.rotateX(Math.PI / 2);
                
                scene.add(cylinderMesh);
                pathMeshes.push(cylinderMesh);
            }
        }

        // 清除路径（原有逻辑，无修改）
        function clearPaths() {
            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];
            document.getElementById('path-detail').style.display = 'none';
        }

        // K最短路径算法（原有逻辑，无修改）
        function kShortestPaths(start, end, k) {
            const paths = [];
            const adj = edges;

            // 简化的Dijkstra求最短路径
            function dijkstra(s, e) {
                const dist = {};
                const prev = {};
                const visited = new Set();
                Object.keys(nodes).forEach(node => dist[node] = Infinity);
                dist[s] = 0;

                while (true) {
                    let minNode = null;
                    Object.keys(nodes).forEach(node => {
                        if (!visited.has(node) && (minNode === null || dist[node] < dist[minNode])) {
                            minNode = node;
                        }
                    });
                    if (minNode === null || minNode === e) break;
                    visited.add(minNode);

                    if (adj[minNode]) {
                        Object.keys(adj[minNode]).forEach(neighbor => {
                            const newDist = dist[minNode] + 1; // 简化：每条边权重为1
                            if (newDist < dist[neighbor]) {
                                dist[neighbor] = newDist;
                                prev[neighbor] = minNode;
                            }
                        });
                    }
                }

                // 回溯路径
                const path = [];
                let curr = e;
                while (curr !== undefined) {
                    path.unshift(curr);
                    curr = prev[curr];
                }
                return path.length > 1 ? path : [];
            }

            // 仅返回前k条（简化版，实际需更复杂逻辑，此处保持原有）
            const shortest = dijkstra(start, end);
            if (shortest.length > 0) paths.push(shortest);
            if (k > 1) paths.push([...shortest].reverse()); // 模拟第二条路径

            return paths.slice(0, k);
        }

        // 鼠标交互（原有逻辑，无修改）
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNode = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(Object.values(nodes).map(n => n.mesh));
            if (hoveredNode) {
                hoveredNode.mesh.material = hoveredNode.materials.default;
                hoveredNode = null;
            }

            if (intersects.length > 0) {
                const node = nodes[intersects[0].object.userData.id];
                if (!selectedNodes.includes(node) && node.mesh.material !== node.materials.start && node.mesh.material !== node.materials.end) {
                    node.mesh.material = node.materials.hover;
                    hoveredNode = node;
                }
            }
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(Object.values(nodes).map(n => n.mesh));
            if (intersects.length === 0) return;

            const clickedNode = nodes[intersects[0].object.userData.id];
            if (selectedNodes.length === 0) {
                // 选择起点
                clickedNode.mesh.material = clickedNode.materials.start;
                selectedNodes.push(clickedNode);
                updateInfo(`已选起点：${clickedNode.id}，请选择终点`);
                clearPaths();
            } else if (selectedNodes.length === 1) {
                // 选择终点
                if (clickedNode === selectedNodes[0]) {
                    updateInfo('起点和终点不能相同，请重新选择终点');
                    return;
                }
                clickedNode.mesh.material = clickedNode.materials.end;
                selectedNodes.push(clickedNode);
                updateInfo(`已选终点：${clickedNode.id}，计算路径中...`);

                // 计算K最短路径
                const paths = kShortestPaths(selectedNodes[0].id, selectedNodes[1].id, CONFIG.K);
                pathData = paths;

                // 绘制路径
                if (paths.length > 0) {
                    drawPath(paths[0], 0, 0xff0000); // 第一条红色
                    document.getElementById('path1').innerText = `路径1：${paths[0].join(' → ')}`;
                }
                if (paths.length > 1) {
                    drawPath(paths[1], 1, 0x8800ff); // 第二条紫色
                    document.getElementById('path2').innerText = `路径2：${paths[1].join(' → ')}`;
                }

                document.getElementById('path-detail').style.display = 'block';
                updateInfo(`路径计算完成，共${paths.length}条`);

                // 重置选中状态（下次点击重新选起点）
                selectedNodes = [];
            }
        }

        // 窗口自适应（原有逻辑，无修改）
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 动画循环（原有逻辑，无修改）
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // 加载数据（原有逻辑，无修改）
        async function loadData() {
            try {
                const response = await fetch('path_data.json');
                if (!response.ok) throw new Error('数据文件加载失败');
                const data = await response.json();
                
                minLon = data.min_lon;
                minLat = data.min_lat;
                nodes = {};
                edges = {};

                // 解析节点
                data.nodes.forEach(node => {
                    nodes[node.id] = {
                        id: node.id,
                        lon: node.lon,
                        lat: node.lat,
                        alt: node.alt
                    };
                });

                // 解析边
                data.edges.forEach(edge => {
                    if (!edges[edge.start]) edges[edge.start] = {};
                    edges[edge.start][edge.end] = {
                        max_cap: edge.max_cap,
                        actual_flow: edge.actual_flow,
                        road_type: edge.road_type
                    };
                    // 双向边
                    if (!edges[edge.end]) edges[edge.end] = {};
                    edges[edge.end][edge.start] = {
                        max_cap: edge.max_cap,
                        actual_flow: edge.actual_flow,
                        road_type: edge.road_type
                    };
                });

                drawNodes();
                drawEdges();
                updateInfo('数据加载完成，点击选择起点和终点');
            } catch (error) {
                updateInfo(`加载失败：${error.message}`, true);
                console.error('数据加载错误：', error);
            }
        }

        // 绑定事件（原有逻辑，无修改）
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', onWindowResize);

        // 初始化
        loadData();
        animate();
    </script>
</body>
</html>
