<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>路径规划可视化系统</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; }
        #info { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; }
        #controls { position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.8); padding: 10px; }
    </style>
</head>
<body>
    <div id="info">加载中...</div>
    <div id="controls">
        <select id="startNode"></select>
        <select id="endNode"></select>
        <button onclick="findAndDrawPaths()">规划路径</button>
    </div>

    <script>
        // 配置参数
        const CONFIG = {
            BOX_SIZE: { x: 0.5, y: 1, z: 0.5 },
            CYLINDER_RADIUS: 0.2,
            SCALE: 100000
        };

        // 全局变量
        let scene, camera, renderer, controls;
        let nodes = {};
        let edges = {};
        let pathMeshes = [];

        // 初始化Three.js场景
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 30);
            scene.add(directionalLight);

            // 加载数据
            loadPathData();

            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // 加载路径数据
        function loadPathData() {
            fetch('path_data.json')
                .then(response => response.json())
                .then(data => {
                    nodes = data.nodes;
                    edges = data.edges;
                    initNodeSelectors();
                    drawNodes();
                    drawEdges();
                    updateInfo(`已加载 ${Object.keys(nodes).length} 个节点和 ${countEdges()} 条通道`);
                })
                .catch(error => console.error('数据加载失败:', error));
        }

        // 初始化节点选择器
        function initNodeSelectors() {
            const startSelect = document.getElementById('startNode');
            const endSelect = document.getElementById('endNode');
            
            Object.keys(nodes).forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = id;
                startSelect.appendChild(option.cloneNode(true));
                endSelect.appendChild(option);
            });
        }

        // 计算边的数量
        function countEdges() {
            let count = 0;
            for (const start in edges) {
                count += Object.keys(edges[start]).length;
            }
            return count;
        }

        // 经纬度转3D坐标
        function lonlatTo3d(lon, lat, alt) {
            const x = (lon - 116.323) * CONFIG.SCALE;
            const z = (lat - 40.0019) * CONFIG.SCALE;
            const y = alt;
            return new THREE.Vector3(x, y, z);
        }

        // 根据海拔获取基础颜色
        function getColorByAlt(alt) {
            const colors = {
                65: 0xaaaaaa,
                70: 0xcccccc,
                75: 0xeeeeee
            };
            return colors[alt] || 0xffffff;
        }

        // 绘制节点
        function drawNodes() {
            for (const id in nodes) {
                const node = nodes[id];
                const pos = lonlatTo3d(node.lon, node.lat, node.alt);
                const alt = node.alt;

                const boxGeo = new THREE.BoxGeometry(
                    CONFIG.BOX_SIZE.x,
                    CONFIG.BOX_SIZE.y,
                    CONFIG.BOX_SIZE.z
                );

                const baseColor = getColorByAlt(alt);
                const materials = {
                    default: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        transparent: false
                    }),
                    hover: new THREE.MeshLambertMaterial({
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8
                    })
                };

                const mesh = new THREE.Mesh(boxGeo, materials.default);
                mesh.position.copy(pos);
                mesh.userData.id = id;
                scene.add(mesh);

                // 节点标签
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.color = 'black';
                div.style.fontSize = '12px';
                div.textContent = id;
                document.body.appendChild(div);
                mesh.userData.label = div;
            }
        }

        // 根据拥挤度获取通道颜色
        function getCrowdColor(actualFlow, maxCap) {
            if (maxCap === 0) return 0xcccccc; // 避免除以零
            const crowd = actualFlow / maxCap;
            if (crowd > 0.8) return 0xff0000; // 红色
            if (crowd > 0.5) return 0xffff00; // 黄色
            return 0x00ff00; // 绿色
        }

        // 绘制通道
        function drawEdges() {
            const processed = new Set();

            for (const start in edges) {
                for (const end in edges[start]) {
                    // 避免重复绘制
                    const key1 = `${start}-${end}`;
                    const key2 = `${end}-${start}`;
                    if (processed.has(key1) || processed.has(key2)) continue;
                    processed.add(key1);

                    const edge = edges[start][end];
                    if (!nodes[start] || !nodes[end]) continue;

                    const startPos = lonlatTo3d(nodes[start].lon, nodes[start].lat, nodes[start].alt);
                    const endPos = lonlatTo3d(nodes[end].lon, nodes[end].lat, nodes[end].alt);
                    const midPoint = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);
                    const length = startPos.distanceTo(endPos);

                    // 根据拥挤度设置通道颜色
                    const edgeColor = getCrowdColor(edge.actual_flow, edge.max_cap);
                    const roadMat = new THREE.MeshLambertMaterial({
                        color: edgeColor,
                        transparent: true,
                        opacity: 0.8
                    });

                    const cylinderGeo = new THREE.CylinderGeometry(
                        CONFIG.CYLINDER_RADIUS,
                        CONFIG.CYLINDER_RADIUS,
                        length,
                        32
                    );

                    const cylinderMesh = new THREE.Mesh(cylinderGeo, roadMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);

                    scene.add(cylinderMesh);
                    edges[start][end].mesh = cylinderMesh;
                }
            }
        }

        // 计算边的权重（带指数惩罚）
        function calculateEdgeWeight(edge) {
            if (edge.max_cap === 0) return Infinity;
            const crowd = edge.actual_flow / edge.max_cap;
            const baseWeight = 1; // 基础权重，可根据实际需求调整
            
            // 指数级惩罚：拥挤度越高惩罚越显著
            // crowd=0 → 惩罚1倍，crowd=0.5 → ~4.48倍，crowd=0.8 → ~11倍，crowd=1 → ~20倍
            const penalty = Math.exp(3 * crowd); 
            return baseWeight * penalty;
        }

        // 寻找路径（改进的Dijkstra算法）
        function findPaths(startNode, endNode, count = 2) {
            const paths = [];
            if (!nodes[startNode] || !nodes[endNode]) return paths;

            // 首次寻找最短路径
            const firstPath = dijkstra(startNode, endNode);
            if (firstPath) paths.push(firstPath);

            // 寻找第二条路径（通过临时移除第一条路径的边）
            if (count >= 2 && firstPath && firstPath.length > 1) {
                // 临时记录并移除第一条路径的边
                const tempRemoved = [];
                for (let i = 0; i < firstPath.length - 1; i++) {
                    const u = firstPath[i];
                    const v = firstPath[i + 1];
                    if (edges[u] && edges[u][v]) {
                        tempRemoved.push({ u, v, edge: edges[u][v] });
                        delete edges[u][v];
                    }
                    if (edges[v] && edges[v][u]) {
                        tempRemoved.push({ u: v, v: u, edge: edges[v][u] });
                        delete edges[v][u];
                    }
                }

                // 寻找第二条路径
                const secondPath = dijkstra(startNode, endNode);
                if (secondPath) paths.push(secondPath);

                // 恢复移除的边
                tempRemoved.forEach(({ u, v, edge }) => {
                    if (!edges[u]) edges[u] = {};
                    edges[u][v] = edge;
                });
            }

            return paths;
        }

        // Dijkstra算法实现
        function dijkstra(start, end) {
            const dist = {};
            const prev = {};
            const nodesSet = new Set(Object.keys(nodes));

            // 初始化距离
            Object.keys(nodes).forEach(node => {
                dist[node] = Infinity;
                prev[node] = null;
            });
            dist[start] = 0;

            while (nodesSet.size > 0) {
                // 找到当前距离最小的节点
                let u = null;
                nodesSet.forEach(node => {
                    if (u === null || dist[node] < dist[u]) {
                        u = node;
                    }
                });

                if (u === end) break; // 到达目标节点
                if (dist[u] === Infinity) break; // 无法到达

                nodesSet.delete(u);

                // 遍历邻居节点
                if (edges[u]) {
                    for (const v in edges[u]) {
                        if (!nodesSet.has(v)) continue;
                        
                        const edge = edges[u][v];
                        const weight = calculateEdgeWeight(edge);
                        const alt = dist[u] + weight;

                        if (alt < dist[v]) {
                            dist[v] = alt;
                            prev[v] = u;
                        }
                    }
                }
            }

            // 重建路径
            const path = [];
            let current = end;
            while (prev[current] !== null) {
                path.unshift(current);
                current = prev[current];
            }
            if (path.length > 0) {
                path.unshift(start);
                return path;
            }
            return null;
        }

        // 绘制路径
        function drawPaths(paths) {
            // 清除已有路径
            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];

            paths.forEach((path, index) => {
                if (path.length < 2) return;

                // 设置路径颜色
                let pathColor;
                if (index === 0) pathColor = 0x0000ff; // 第一条：蓝色
                else if (index === 1) pathColor = 0x800080; // 第二条：紫色
                else pathColor = 0xffffff; // 其他：白色

                const pathMat = new THREE.MeshLambertMaterial({
                    color: pathColor,
                    transparent: true,
                    opacity: 0.9
                });

                // 绘制路径线段
                for (let i = 0; i < path.length - 1; i++) {
                    const startId = path[i];
                    const endId = path[i + 1];
                    const startNode = nodes[startId];
                    const endNode = nodes[endId];

                    if (!startNode || !endNode) continue;

                    const startPos = lonlatTo3d(startNode.lon, startNode.lat, startNode.alt);
                    const endPos = lonlatTo3d(endNode.lon, endNode.lat, endNode.alt);
                    const midPoint = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);
                    const length = startPos.distanceTo(endPos);

                    const cylinderGeo = new THREE.CylinderGeometry(
                        CONFIG.CYLINDER_RADIUS * 1.5, // 路径略粗于通道
                        CONFIG.CYLINDER_RADIUS * 1.5,
                        length,
                        32
                    );

                    const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);

                    scene.add(cylinderMesh);
                    pathMeshes.push(cylinderMesh);
                }
            });
        }

        // 规划并绘制路径
        function findAndDrawPaths() {
            const start = document.getElementById('startNode').value;
            const end = document.getElementById('endNode').value;
            if (start === end) {
                updateInfo('起点和终点不能相同');
                return;
            }

            const paths = findPaths(start, end, 2);
            if (paths.length === 0) {
                updateInfo('未找到可用路径');
            } else {
                drawPaths(paths);
                updateInfo(`找到 ${paths.length} 条路径（蓝色：第一条，紫色：第二条）`);
            }
        }

        // 更新信息面板
        function updateInfo(text) {
            document.getElementById('info').textContent = text;
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            
            // 更新节点标签位置
            for (const id in nodes) {
                const node = scene.children.find(child => child.userData.id === id);
                if (node && node.userData.label) {
                    const pos = new THREE.Vector3().setFromMatrixPosition(node.matrixWorld);
                    pos.project(camera);
                    const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                    node.userData.label.style.left = `${x}px`;
                    node.userData.label.style.top = `${y}px`;
                }
            }
        }

        // 初始化
        window.onload = init;
    </script>
</body>
</html>
