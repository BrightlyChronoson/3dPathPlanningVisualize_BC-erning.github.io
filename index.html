<!DOCTYPE html>
<html>
<head>
    <title>ç¬¬å…­æ•™å­¦æ¥¼BåŒº3Dè·¯å¾„è§„åˆ’>di'liu'
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.9); 
            padding: 12px 15px; 
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px;
            color: #333;
            z-index: 100;
        }
        #path-detail {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            display: none;
            z-index: 100;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            color: #333;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .erroræç¤º {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">ç‚¹å‡»ç¬¬ä¸€ä¸ªé•¿æ–¹ä½“ä½œä¸ºèµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰ï¼Œç¬¬äºŒä¸ªä½œä¸ºç»ˆç‚¹ï¼ˆè“è‰²ï¼‰</div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">è·¯å¾„è¯¦æƒ…</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">å›¾ä¾‹</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span>æ•™å®¤</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffffbd;"></div>
            <span>æ‚¬åœæ•™å®¤</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>èµ·ç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>ç»ˆç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #006600;"></div>
            <span>è¿æ¥é€šé“</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>ç¬¬1æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>ç¬¬2æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
    </div>

    <script>
        // 1. å…¨å±€é…ç½®ï¼šä¿®æ­£åæ ‡è½´æ˜ å°„
        const CONFIG = {
            SCALE: 100000000,         // åæ ‡ç¼©æ”¾ç³»æ•°ï¼ˆæ‹‰å¼€æ°´å¹³è·ç¦»ï¼‰
            ALTITUDE_SCALE:1000,
            K: 2,                 // æœ€çŸ­è·¯å¾„æ•°é‡
            BOX_SIZE: { x: 2000, y: 500, z: 2000 }, // é•¿æ–¹ä½“ï¼šx/zæ°´å¹³ï¼Œyå‚ç›´ï¼ˆæ¥¼å±‚é«˜åº¦ï¼‰
            EDGE_WIDTH: 60,        // é€šé“å®½åº¦
            PATH_WIDTH: 100        // è·¯å¾„å®½åº¦
        };
        let minLon = 0, minLat = 0;
        let nodes = {};         // èŠ‚ç‚¹æ•°æ®
        let edges = {};         // è¾¹æ•°æ®
        let selectedNodes = []; // é€‰ä¸­èŠ‚ç‚¹
        let pathMeshes = [];    // è·¯å¾„ç½‘æ ¼
        let pathData = [];      // è·¯å¾„è¯¦æƒ…

        // 2. Three.jsæ ¸å¿ƒå¯¹è±¡åˆå§‹åŒ–
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);

        // ç›¸æœºï¼šé€‚é…yè½´ä¸ºé«˜åº¦ï¼Œè®¾ç½®æ°´å¹³è§†è§’
        const camera = new THREE.PerspectiveCamera(
            55,                  
            window.innerWidth / window.innerHeight,
            0.1,
            500000
        );
        camera.position.set(20000, 15000, 20000); // è°ƒæ•´ä¸ºæ°´å¹³æˆ–ç¨é«˜è§†è§’ï¼Œé¿å…ä»ä¸‹å¾€ä¸Šçœ‹
        camera.lookAt(new THREE.Vector3(0, 70, 0)); // çœ‹å‘åœºæ™¯ä¸­å¿ƒ

        // æ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // è½¨é“æ§åˆ¶å™¨ï¼šé™åˆ¶ç›¸æœºè§’åº¦ï¼Œä¸å…è®¸ä»ä¸‹æ–¹æŸ¥çœ‹
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 5000;  
        controls.maxDistance = 100000;
        controls.target.set(0, 70, 0);
        controls.maxPolarAngle = Math.PI / 2; // é™åˆ¶æœ€å¤§æè§’ä¸º90åº¦ï¼ˆæ°´å¹³è§†è§’ï¼‰

        // 3. å…‰ç…§ç³»ç»Ÿ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 0.8);
        spotLight.position.set(20000, 20000, 20000); // æ–œä¸Šæ–¹å…‰æº
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.set(2048, 2048);
        spotLight.shadow.camera.near = 100;
        spotLight.shadow.camera.far = 100000;
        scene.add(spotLight);

        // 4. è¾…åŠ©å…ƒç´ 
        const gridHelper = new THREE.GridHelper(100000, 50); // åœ°é¢ç½‘æ ¼ï¼šx/zå¹³é¢
        gridHelper.position.y = 0; // ç½‘æ ¼åœ¨y=0å¤„ï¼ˆåº•å±‚åœ°é¢ï¼‰
        gridHelper.material.opacity = 0.5;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(10000); // åæ ‡è½´ï¼šxçº¢ã€yç»¿ã€zè“
        scene.add(axesHelper);

        // 5. å·¥å…·å‡½æ•°ï¼šä¿®æ­£åæ ‡æ˜ å°„ï¼ˆæµ·æ‹”â†’yè½´ï¼‰
        function lonlatTo3d(lon, lat, alt) {
            const x = (lon - minLon) * CONFIG.SCALE - 35000; // ç»åº¦â†’xè½´ï¼ˆæ°´å¹³ï¼‰
            const y = alt * CONFIG.ALTITUDE_SCALE - 60000;   // æµ·æ‹”â†’yè½´ï¼ˆå‚ç›´é«˜åº¦ï¼‰
            const z = (lat - minLat) * CONFIG.SCALE - 15000; // çº¬åº¦â†’zè½´ï¼ˆæ°´å¹³ï¼‰
            return new THREE.Vector3(x, y, z);
        }

        // ç»Ÿä¸€ä½¿ç”¨ç°è‰²è¡¨ç¤ºæœªé€‰æ‹©çš„æ•™å®¤
        function getColorByAlt(alt) {
            return 0x999999; // ç°è‰²
        }

        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="erroræç¤º">${text}</span>` : text;
        }

        // 6. ç»˜åˆ¶å‡½æ•°
        function drawEdges() {
            const sideRoadMat = new THREE.LineBasicMaterial({
                color: 0x006600,
                linewidth: CONFIG.EDGE_WIDTH
            });

            const processed = new Set();
            for (const start in edges) {
                for (const end in edges[start]) {
                    const key = `${start}-${end}`;
                    const reverseKey = `${end}-${start}`;
                    if (processed.has(key) || processed.has(reverseKey)) continue;
                    processed.add(key);

                    if (!nodes[start] || !nodes[end]) continue;

                    // é€šé“ä¸¤ç«¯åæ ‡ï¼ˆyè½´ä¸ºé«˜åº¦ï¼‰
                    const startPos = lonlatTo3d(
                        nodes[start].lon,
                        nodes[start].lat,
                        nodes[start].alt
                    );
                    const endPos = lonlatTo3d(
                        nodes[end].lon,
                        nodes[end].lat,
                        nodes[end].alt
                    );

                    const geo = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                    const line = new THREE.Line(geo, sideRoadMat);
                    scene.add(line);
                    edges[start][end].mesh = line;
                }
            }
            updateInfo(`å·²åŠ è½½ ${processed.size} æ¡é€šé“ï¼Œæ¥¼å±‚å‚ç›´åˆ†å±‚æ˜¾ç¤º`);
        }

        function drawNodes() {
            for (const id in nodes) {
                const node = nodes[id];
                const pos = lonlatTo3d(node.lon, node.lat, node.alt); // yè½´ä¸ºæµ·æ‹”
                const alt = node.alt;

                // é•¿æ–¹ä½“å‡ ä½•ä½“ï¼šx/zæ°´å¹³ï¼Œyå‚ç›´ï¼ˆå¯¹åº”æ¥¼å±‚é«˜åº¦ï¼‰
                const boxGeo = new THREE.BoxGeometry(
                    CONFIG.BOX_SIZE.x,
                    CONFIG.BOX_SIZE.y,
                    CONFIG.BOX_SIZE.z
                );

                const baseColor = getColorByAlt(alt);
                const materials = {
                    default: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        transparent: false
                    }),
                    hover: new THREE.MeshLambertMaterial({
                        color: baseColor,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3,
                        transparent: false
                    }),
                    start: new THREE.MeshLambertMaterial({
                        color: 0x00ff00,
                        transparent: false
                    }),
                    end: new THREE.MeshLambertMaterial({
                        color: 0x0000ff,
                        transparent: false
                    })
                };

                const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                boxMesh.position.copy(pos);
                boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                scene.add(boxMesh);

                nodes[id] = {
                    ...node,
                    mesh: boxMesh,
                    materials,
                    originalScale: new THREE.Vector3(1, 1, 1)
                };
            }
        }

        function drawPath(path, index, color) {
            const pathPoints = path.map(nodeId => {
                return nodes[nodeId].mesh.position.clone();
            });

            const geo = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const mat = new THREE.LineBasicMaterial({
                color,
                linewidth: CONFIG.PATH_WIDTH,
                transparent: true,
                opacity: 0.9
            });
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            pathMeshes.push(line);

            const weight = calculatePathWeight(path);
            const length = calculatePathLength(path);
            pathData.push({ index, nodes: path, weight, length });

            const pathEl = document.getElementById(`path${index}`);
            pathEl.innerHTML = `
                <div style="font-weight: bold;">ç¬¬${index}æ¡è·¯å¾„</div>
                <div>æ•™å®¤åºåˆ—ï¼š${path.join(' â†’ ')}</div>
                <div>é€šé“æ€»é•¿ï¼š${length.toFixed(2)} ç±³</div>
                <div>ç»¼åˆæƒé‡ï¼š${weight.toFixed(2)}</div>
            `;
            document.getElementById('path-detail').style.display = 'block';
        }

        // 7. è·¯å¾„ç®—æ³•ï¼ˆæ— ä¿®æ”¹ï¼‰
        function calculateEdgeWeight(startId, endId) {
            if (!edges[startId] || !edges[startId][endId]) return Infinity;
            
            const start = nodes[startId];
            const end = nodes[endId];
            const edge = edges[startId][endId];

            const x1 = start.lon * 111000;
            const y1 = start.lat * 111000;
            const x2 = end.lon * 111000;
            const y2 = end.lat * 111000;
            const geoDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

            const congestion = edge.actual_flow / edge.max_cap;
            let congestionCoeff = 1.0;
            if (0.7 < congestion <= 0.9) congestionCoeff = 1.5;
            else if (0.9 < congestion <= 1.0) congestionCoeff = 2.0;
            else if (congestion > 1.0) congestionCoeff = 3.0;
            const congestionRatio = congestion <= 1 ? 1.0 : 1 + (congestion - 1) * congestionCoeff;

            const roadCoeff = edge.road_type === 'main' ? 0.9 : 1.2;

            const altDiff = end.alt - start.alt;
            const altPenalty = altDiff > 0 ? altDiff * 0.001 : Math.abs(altDiff) * 0.0012;

            return congestionRatio * geoDist * roadCoeff + altPenalty;
        }

        function calculatePathWeight(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                total += calculateEdgeWeight(path[i], path[i + 1]);
            }
            return total;
        }

        function calculatePathLength(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const start = nodes[path[i]];
                const end = nodes[path[i + 1]];
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                total += Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }
            return total;
        }

        function dijkstra(startId, endId) {
            const distances = {};
            const predecessors = {};
            const unvisited = new Set(Object.keys(nodes));

            Object.keys(nodes).forEach(id => {
                distances[id] = Infinity;
                predecessors[id] = null;
            });
            distances[startId] = 0;

            while (unvisited.size > 0) {
                let currentId = null;
                let minDist = Infinity;
                for (const id of unvisited) {
                    if (distances[id] < minDist) {
                        minDist = distances[id];
                        currentId = id;
                    }
                }

                if (currentId === null || currentId === endId) break;
                unvisited.delete(currentId);

                for (const neighborId in edges[currentId]) {
                    if (!unvisited.has(neighborId)) continue;
                    const newDist = distances[currentId] + calculateEdgeWeight(currentId, neighborId);
                    if (newDist < distances[neighborId]) {
                        distances[neighborId] = newDist;
                        predecessors[neighborId] = currentId;
                    }
                }
            }

            const path = [];
            let current = endId;
            while (current !== null) {
                path.push(current);
                current = predecessors[current];
            }
            path.reverse();

            return path[0] === startId ? path : null;
        }

        function yenKShortestPaths(startId, endId, k) {
            const shortestPaths = [];
            const firstPath = dijkstra(startId, endId);
            if (!firstPath) return [];
            shortestPaths.push(firstPath);

            const tempEdges = JSON.parse(JSON.stringify(edges));

            for (let i = 1; i < k; i++) {
                const prevPath = shortestPaths[i - 1];
                const candidates = [];

                for (let j = 0; j < prevPath.length - 1; j++) {
                    const spurNode = prevPath[j];
                    const rootPath = prevPath.slice(0, j + 1);

                    const removedEdges = [];
                    shortestPaths.forEach(path => {
                        if (path.slice(0, j + 1).join(',') === rootPath.join(',')) {
                            const u = path[j];
                            const v = path[j + 1];
                            if (tempEdges[u] && tempEdges[u][v]) {
                                removedEdges.push({ u, v, data: tempEdges[u][v] });
                                delete tempEdges[u][v];
                                if (tempEdges[v] && tempEdges[v][u]) {
                                    removedEdges.push({ u: v, v: u, data: tempEdges[v][u] });
                                    delete tempEdges[v][u];
                                }
                            }
                        }
                    });

                    const spurPath = dijkstra(spurNode, endId);
                    if (spurPath) {
                        const combinedPath = [...rootPath.slice(0, -1), ...spurPath];
                        if (!candidates.some(c => c.join(',') === combinedPath.join(','))) {
                            candidates.push(combinedPath);
                        }
                    }

                    removedEdges.forEach(({ u, v, data }) => {
                        if (!tempEdges[u]) tempEdges[u] = {};
                        tempEdges[u][v] = data;
                        if (!tempEdges[v]) tempEdges[v] = {};
                        tempEdges[v][u] = data;
                    });
                }

                if (candidates.length === 0) break;
                candidates.sort((a, b) => calculatePathWeight(a) - calculatePathWeight(b));
                shortestPaths.push(candidates[0]);
            }

            return shortestPaths;
        }

        // 8. äº¤äº’é€»è¾‘
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNodeId = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                Object.values(nodes).map(n => n.mesh),
                false
            );

            if (hoveredNodeId && !selectedNodes.includes(hoveredNodeId)) {
                const prevNode = nodes[hoveredNodeId];
                prevNode.mesh.material = prevNode.materials.default;
                prevNode.mesh.scale.copy(prevNode.originalScale);
                hoveredNodeId = null;
            }

            if (intersects.length > 0) {
                const targetNode = intersects[0].object;
                const nodeId = targetNode.userData.id;
                if (!selectedNodes.includes(nodeId)) {
                    hoveredNodeId = nodeId;
                    const currNode = nodes[nodeId];
                    currNode.mesh.material = currNode.materials.hover;
                    currNode.mesh.scale.set(1.2, 1.2, 1.2);
                }
            }
        }

        function onMouseClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(
                Object.values(nodes).map(n => n.mesh),
                false
            );

            if (intersects.length === 0) {
                updateInfo("è¯·ç‚¹å‡»æœ‰æ•ˆæ•™å®¤ï¼ˆç°è‰²é•¿æ–¹ä½“ï¼‰", true);
                return;
            }

            const targetNode = intersects[0].object;
            const nodeId = targetNode.userData.id;

            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];
            pathData = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';

            if (selectedNodes.length === 0) {
                selectedNodes.push(nodeId);
                nodes[nodeId].mesh.material = nodes[nodeId].materials.start;
                nodes[nodeId].mesh.scale.copy(nodes[nodeId].originalScale);
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            } else if (selectedNodes.length === 1) {
                if (nodeId === selectedNodes[0]) {
                    updateInfo("âŒ ä¸èƒ½é€‰æ‹©åŒä¸€é•¿æ–¹ä½“ä½œä¸ºç»ˆç‚¹ï¼Œè¯·é‡æ–°ç‚¹å‡»", true);
                    return;
                }

                selectedNodes.push(nodeId);
                nodes[nodeId].mesh.material = nodes[nodeId].materials.end;
                nodes[nodeId].mesh.scale.copy(nodes[nodeId].originalScale);
                updateInfo(`ğŸ” æ­£åœ¨è®¡ç®—è·¯å¾„ï¼š${selectedNodes[0]} â†’ ${nodeId}`);

                const kPaths = yenKShortestPaths(selectedNodes[0], nodeId, CONFIG.K);
                if (kPaths.length === 0) {
                    updateInfo(`âŒ æœªæ‰¾åˆ°ä» ${selectedNodes[0]} åˆ° ${nodeId} çš„è·¯å¾„`, true);
                } else {
                    updateInfo(`âœ… æ‰¾åˆ° ${kPaths.length} æ¡è·¯å¾„ï¼Œç‚¹å‡»ç©ºç™½å¤„é‡æ–°é€‰æ‹©`);
                    const pathColors = [0xff0000, 0x8800ff];
                    kPaths.forEach((path, idx) => {
                        drawPath(path, idx + 1, pathColors[idx]);
                    });
                }
            } else {
                selectedNodes.forEach(id => {
                    nodes[id].mesh.material = nodes[id].materials.default;
                    nodes[id].mesh.scale.copy(nodes[id].originalScale);
                });
                selectedNodes = [nodeId];
                nodes[nodeId].mesh.material = nodes[nodeId].materials.start;
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            }
        }

        // 9. æ•°æ®åŠ è½½
        function loadData() {
            fetch('path_data.json')
                .then(response => {
                    if (!response.ok) throw new Error(`æ•°æ®åŠ è½½å¤±è´¥ï¼ˆ${response.status}ï¼‰`);
                    return response.json();
                })
                .then(data => {
                    minLon = data.min_lon;
                    minLat = data.min_lat;
                    nodes = data.nodes;
                    edges = data.edges;

                    if (!nodes || Object.keys(nodes).length === 0) throw new Error("èŠ‚ç‚¹æ•°æ®ä¸ºç©º");
                    if (!edges || Object.keys(edges).length === 0) throw new Error("è¾¹æ•°æ®ä¸ºç©º");

                    drawEdges();
                    drawNodes();
                })
                .catch(error => {
                    updateInfo(`âš ï¸ åˆå§‹åŒ–å¤±è´¥ï¼š${error.message}`, true);
                    if (error.message.includes('404')) {
                        updateInfo(`âš ï¸ æœªæ‰¾åˆ°path_data.jsonï¼ˆè¯·ç¡®ä¿ä¸index.htmlåŒç›®å½•ï¼‰`, true);
                    } else if (error.message.includes('JSON')) {
                        updateInfo(`âš ï¸ path_data.jsonæ ¼å¼é”™è¯¯ï¼ˆé‡æ–°è¿è¡ŒPythonå¯¼å‡ºï¼‰`, true);
                    }
                });
        }

        // 10. äº‹ä»¶ä¸åŠ¨ç”»
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        loadData();
        animate();
    </script>
</body>

</html>
