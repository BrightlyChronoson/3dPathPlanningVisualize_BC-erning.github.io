<!DOCTYPE html>
<html>
<head>
    <title>第六教学楼B区3D路径规划</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.9); 
            padding: 12px 15px; 
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px;
            color: #333;
            z-index: 100;
        }
        #path-detail {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            display: none;
            z-index: 100;
            max-width: 400px;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            color: #333;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .error提示 {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">点击第一个长方体作为起点（绿色），第二个作为终点（蓝色）</div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">路径详情</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">图例</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span>教室/楼梯</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>悬停状态</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>起点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>终点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>通道（拥挤度 < 0.5）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffff00;"></div>
            <span>通道（0.5 ≤ 拥挤度 ≤ 0.8）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>通道（拥挤度 > 0.8）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>第1条最短路径</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>第2条最短路径</span>
        </div>
    </div>

    <script>
        // 1. 全局配置（严格匹配JSON中的scale）
        const CONFIG = {
            SCALE: 1000,              // 直接使用JSON中的scale值
            ALTITUDE_SCALE: 50,       // 海拔缩放（适配楼层高度）
            K: 2,                     // 最短路径数量
            BOX_SIZE: { x: 1, y: 2, z: 1 }, // 教室/楼梯尺寸（适配缩放后坐标）
            EDGE_RADIUS: 0.1,         // 通道半径（适配缩放后坐标）
            PATH_RADIUS: 0.15         // 路径半径（适配缩放后坐标）
        };
        let minLon = 0, minLat = 0;
        let nodes = {};         // 节点数据（匹配JSON的nodes结构）
        let edges = {};         // 边数据（匹配JSON的edges嵌套对象结构）
        let selectedNodes = []; // 选中节点
        let pathMeshes = [];    // 路径网格
        let pathData = [];      // 路径详情

        // 2. Three.js核心对象初始化
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);

        // 相机（适配缩放后的坐标）
        const camera = new THREE.PerspectiveCamera(
            60,                  
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(5, 8, 8); // 适配缩放后的视角
        camera.lookAt(new THREE.Vector3(0, 3, 0));

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 轨道控制器（适配缩放后的操作）
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 2;  
        controls.maxDistance = 50;
        controls.target.set(0, 3, 0);
        controls.maxPolarAngle = Math.PI / 2; // 限制从下方查看

        // 3. 光照系统
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 0.8);
        spotLight.position.set(10, 15, 10);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.set(2048, 2048);
        spotLight.shadow.camera.near = 0.1;
        spotLight.shadow.camera.far = 100;
        scene.add(spotLight);

        // 4. 辅助元素（适配缩放后坐标）
        const gridHelper = new THREE.GridHelper(20, 40); // 地面网格
        gridHelper.position.y = 0;
        gridHelper.material.opacity = 0.5;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(5); // 坐标轴
        scene.add(axesHelper);

        // 5. 核心工具函数（严格匹配JSON坐标）
        /**
         * 经纬度+海拔转3D坐标（严格基于JSON的min_lon/min_lat/scale）
         */
        function lonlatTo3d(lon, lat, alt) {
            const x = (lon - minLon) * CONFIG.SCALE;
            const y = (alt - 60) * CONFIG.ALTITUDE_SCALE; // 60为最低海拔，让底层在y=0附近
            const z = (lat - minLat) * CONFIG.SCALE;
            return new THREE.Vector3(x, y, z);
        }

        /**
         * 更新信息面板
         */
        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="error提示">${text}</span>` : text;
        }

        // 6. 绘制函数（严格匹配JSON结构）
        /**
         * 绘制通道（edges嵌套对象遍历）
         */
        function drawEdges() {
            const processed = new Set(); // 避免重复绘制双向边
            let edgeCount = 0;

            // 遍历JSON的edges嵌套结构
            for (const startId in edges) {
                const endMap = edges[startId];
                for (const endId in endMap) {
                    // 生成唯一键，避免重复处理
                    const edgeKey = [startId, endId].sort().join('-');
                    if (processed.has(edgeKey)) continue;
                    processed.add(edgeKey);

                    // 验证节点存在性
                    if (!nodes[startId] || !nodes[endId]) {
                        console.warn(`跳过无效边: ${startId} → ${endId}（节点不存在）`);
                        continue;
                    }

                    // 获取边的拥挤度数据（严格匹配JSON字段）
                    const edgeProps = endMap[endId];
                    const maxCap = edgeProps.max_cap || 0;
                    const actualFlow = edgeProps.actual_flow || 0;
                    const crowdRate = maxCap > 0 ? actualFlow / maxCap : 0;

                    // 拥挤度上色
                    let edgeColor;
                    if (crowdRate < 0.5) edgeColor = 0x00ff00;    // 绿色（宽松）
                    else if (crowdRate <= 0.8) edgeColor = 0xffff00; // 黄色（中等）
                    else edgeColor = 0xff0000;                     // 红色（拥挤）

                    // 创建通道材质
                    const edgeMat = new THREE.MeshLambertMaterial({
                        color: edgeColor,
                        transparent: true,
                        opacity: 0.7
                    });

                    // 计算通道两端3D坐标
                    const startPos = lonlatTo3d(
                        nodes[startId].lon,
                        nodes[startId].lat,
                        nodes[startId].alt
                    );
                    const endPos = lonlatTo3d(
                        nodes[endId].lon,
                        nodes[endId].lat,
                        nodes[endId].alt
                    );

                    // 创建圆柱体通道
                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                    const cylinderGeo = new THREE.CylinderGeometry(
                        CONFIG.EDGE_RADIUS,
                        CONFIG.EDGE_RADIUS,
                        length,
                        16
                    );
                    const cylinderMesh = new THREE.Mesh(cylinderGeo, edgeMat);
                    
                    // 定位并旋转圆柱体
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);
                    cylinderMesh.castShadow = true;

                    scene.add(cylinderMesh);
                    edgeCount++;
                }
            }
            updateInfo(`已加载 ${edgeCount} 条通道（基于path_data.json）`);
        }

        /**
         * 绘制节点（教室+楼梯，严格匹配JSON的nodes结构）
         */
        function drawNodes() {
            let nodeCount = 0;
            for (const nodeId in nodes) {
                const node = nodes[nodeId];
                // 强制挂载id属性（解决undefined问题）
                node.id = nodeId;
                
                // 计算3D坐标
                const pos = lonlatTo3d(node.lon, node.lat, node.alt);

                // 定义材质（默认/悬停/起点/终点）
                const materials = {
                    default: new THREE.MeshLambertMaterial({ color: 0x999999 }),
                    hover: new THREE.MeshLambertMaterial({ color: 0xeeeeaa, emissive: 0xffff00, emissiveIntensity: 0.2 }),
                    start: new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
                    end: new THREE.MeshLambertMaterial({ color: 0x0000ff })
                };

                // 创建长方体节点
                const boxGeo = new THREE.BoxGeometry(
                    CONFIG.BOX_SIZE.x,
                    CONFIG.BOX_SIZE.y,
                    CONFIG.BOX_SIZE.z
                );
                const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                
                // 设置位置和用户数据
                boxMesh.position.copy(pos);
                boxMesh.userData = { id: nodeId };
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;

                // 添加到场景
                scene.add(boxMesh);

                // 保存节点完整信息
                nodes[nodeId] = {
                    ...node,
                    mesh: boxMesh,
                    materials: materials,
                    originalScale: boxMesh.scale.clone()
                };
                nodeCount++;
            }
            updateInfo(`已加载 ${nodeCount} 个节点（教室+楼梯）`);
        }

        /**
         * 绘制路径
         */
        function drawPath(path, index, color) {
            if (!path || path.length < 2) return;

            const pathMat = new THREE.MeshLambertMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });

            for (let i = 0; i < path.length - 1; i++) {
                const nodeId1 = path[i];
                const nodeId2 = path[i + 1];

                if (!nodes[nodeId1] || !nodes[nodeId2]) continue;

                // 计算路径端点坐标
                const startPos = lonlatTo3d(
                    nodes[nodeId1].lon,
                    nodes[nodeId1].lat,
                    nodes[nodeId1].alt
                );
                const endPos = lonlatTo3d(
                    nodes[nodeId2].lon,
                    nodes[nodeId2].lat,
                    nodes[nodeId2].alt
                );

                // 创建路径圆柱体
                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                const cylinderGeo = new THREE.CylinderGeometry(
                    CONFIG.PATH_RADIUS,
                    CONFIG.PATH_RADIUS,
                    length,
                    16
                );
                const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                
                cylinderMesh.position.copy(midPoint);
                cylinderMesh.lookAt(endPos);
                cylinderMesh.rotateX(Math.PI / 2);
                cylinderMesh.castShadow = true;

                scene.add(cylinderMesh);
                pathMeshes.push(cylinderMesh);
            }
        }

        /**
         * 清除路径
         */
        function clearPaths() {
            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerText = '';
            document.getElementById('path2').innerText = '';
        }

        // 7. 路径算法（适配JSON的edges嵌套结构）
        /**
         * K最短路径算法（Dijkstra基础版，适配嵌套edges）
         */
        function kShortestPaths(startId, endId, k) {
            const paths = [];

            // 基础Dijkstra算法
            function dijkstra(s, e) {
                // 初始化距离和前驱
                const dist = {};
                const prev = {};
                const visited = new Set();

                // 初始化所有节点距离为无穷大
                for (const nodeId in nodes) {
                    dist[nodeId] = Infinity;
                }
                dist[s] = 0;

                // 核心Dijkstra循环
                while (true) {
                    // 找到未访问的最小距离节点
                    let minNode = null;
                    let minDist = Infinity;
                    for (const nodeId in nodes) {
                        if (!visited.has(nodeId) && dist[nodeId] < minDist) {
                            minDist = dist[nodeId];
                            minNode = nodeId;
                        }
                    }

                    if (minNode === null || minNode === e) break;
                    visited.add(minNode);

                    // 遍历邻接节点（适配edges嵌套结构）
                    if (edges[minNode]) {
                        for (const neighborId in edges[minNode]) {
                            if (visited.has(neighborId)) continue;
                            const newDist = dist[minNode] + 1; // 边权重为1
                            if (newDist < dist[neighborId]) {
                                dist[neighborId] = newDist;
                                prev[neighborId] = minNode;
                            }
                        }
                    }
                }

                // 回溯路径
                const path = [];
                let curr = e;
                while (curr !== undefined && curr !== s) {
                    path.unshift(curr);
                    curr = prev[curr];
                }

                // 验证路径有效性
                if (curr === s) {
                    path.unshift(s);
                    return path;
                }
                return []; // 无有效路径
            }

            // 获取最短路径
            const shortestPath = dijkstra(startId, endId);
            if (shortestPath.length > 1) {
                paths.push(shortestPath);
                
                // 生成第二条路径（反转最短路径，模拟K=2）
                if (k > 1) {
                    const reversePath = [...shortestPath].reverse();
                    if (reversePath.length > 1) paths.push(reversePath);
                }
            }

            return paths.slice(0, k);
        }

        // 8. 鼠标交互（严格匹配节点ID）
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNode = null;

        /**
         * 鼠标移动 - 悬停效果
         */
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // 重置上一个悬停节点
            if (hoveredNode) {
                hoveredNode.mesh.material = hoveredNode.materials.default;
                hoveredNode = null;
            }

            // 检测节点碰撞
            const nodeMeshes = Object.values(nodes).map(n => n.mesh);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            
            if (intersects.length > 0) {
                const clickedNodeId = intersects[0].object.userData.id;
                const node = nodes[clickedNodeId];
                
                // 仅对未选中节点添加悬停效果
                if (node && 
                    node.mesh.material !== node.materials.start && 
                    node.mesh.material !== node.materials.end) {
                    node.mesh.material = node.materials.hover;
                    hoveredNode = node;
                }
            }
        }

        /**
         * 鼠标点击 - 选择起点/终点+计算路径
         */
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // 检测点击的节点
            const nodeMeshes = Object.values(nodes).map(n => n.mesh);
            const intersects = raycaster.intersectObjects(nodeMeshes);
            if (intersects.length === 0) return;

            // 获取点击的节点ID（核心：从userData取ID）
            const clickedNodeId = intersects[0].object.userData.id;
            const clickedNode = nodes[clickedNodeId];
            if (!clickedNode) return;

            // 选择起点
            if (selectedNodes.length === 0) {
                clickedNode.mesh.material = clickedNode.materials.start;
                selectedNodes.push(clickedNode);
                updateInfo(`已选起点：${clickedNode.id}，请选择终点`);
                clearPaths();
            } 
            // 选择终点
            else if (selectedNodes.length === 1) {
                // 验证起点终点不同
                if (clickedNode.id === selectedNodes[0].id) {
                    updateInfo('起点和终点不能相同，请重新选择终点');
                    return;
                }

                clickedNode.mesh.material = clickedNode.materials.end;
                selectedNodes.push(clickedNode);
                updateInfo(`已选终点：${clickedNode.id}，计算路径中...`);

                // 计算K最短路径
                const paths = kShortestPaths(selectedNodes[0].id, clickedNode.id, CONFIG.K);
                pathData = paths;

                // 显示路径详情
                document.getElementById('path-detail').style.display = 'block';
                if (paths.length > 0) {
                    drawPath(paths[0], 0, 0xff0000); // 第一条：红色
                    document.getElementById('path1').innerText = `路径1：${paths[0].join(' → ')}`;
                }
                if (paths.length > 1) {
                    drawPath(paths[1], 1, 0x8800ff); // 第二条：紫色
                    document.getElementById('path2').innerText = `路径2：${paths[1].join(' → ')}`;
                }

                // 更新信息
                updateInfo(`路径计算完成，共${paths.length}条有效路径`);

                // 重置选中状态（下次点击重新选起点）
                selectedNodes = [];
            }
        }

        // 9. 窗口自适应
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 10. 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // 11. 加载数据（严格匹配JSON结构）
        async function loadData() {
            try {
                updateInfo('正在加载path_data.json...');
                
                // 加载JSON文件
                const response = await fetch('path_data.json');
                if (!response.ok) throw new Error(`HTTP错误：${response.status}`);
                const data = await response.json();

                // 初始化全局变量（严格匹配JSON字段）
                minLon = data.min_lon;
                minLat = data.min_lat;
                nodes = { ...data.nodes }; // 直接复制nodes对象
                edges = { ...data.edges }; // 直接复制edges嵌套对象

                // 绘制节点和通道
                drawNodes();
                drawEdges();

                updateInfo('数据加载完成！点击选择起点和终点');
            } catch (error) {
                updateInfo(`加载失败：${error.message}`, true);
                console.error('数据加载详细错误：', error);
            }
        }

        // 12. 绑定事件+初始化
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', onWindowResize);

        // 启动程序
        loadData();
        animate();
    </script>
</body>
</html>
