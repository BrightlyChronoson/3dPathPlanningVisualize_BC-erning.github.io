<!DOCTYPE html>
<html>
<head>
    <title>第六教学楼B区3D路径规划</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.9); 
            padding: 12px 15px; 
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px;
            color: #333;
            z-index: 100;
        }
        #path-detail {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            color: #333;
            display: none;
            z-index: 100;
        }
        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 12px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            color: #333;
            z-index: 100;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .error提示 {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info-panel">点击第一个长方体作为起点（绿色），第二个作为终点（蓝色）</div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">路径详情</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">图例</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span>教室</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>悬停教室</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>起点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>终点</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00cc00;"></div>
            <span>畅通通道 (crowd < 0.5)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffff00;"></div>
            <span>拥挤通道 (0.5 ≤ crowd ≤ 0.8)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff0000;"></div>
            <span>堵塞通道 (crowd > 0.8)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>第1条最短路径</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>第2条最短路径</span>
        </div>
    </div>

    <script>
        // 1. 全局配置：修正坐标轴映射
        const CONFIG = {
            SCALE: 100000000,         // 坐标缩放系数（拉开水平距离）
            ALTITUDE_SCALE:1000,
            K: 2,                 // 最短路径数量
            BOX_SIZE: { x: 2000, y: 500, z: 2000 }, // 长方体：x/z水平，y垂直（楼层高度）
            EDGE_WIDTH: 15,        // 通道宽度
            PATH_WIDTH: 20,        // 路径宽度
            CONGESTION_PENALTY: 5   // 拥挤度惩罚系数
        };
        let minLon = 0, minLat = 0;
        let nodes = {};         // 节点数据
        let edges = {};         // 边数据
        let selectedNodes = []; // 选中节点
        let pathMeshes = [];    // 路径网格
        let pathData = [];      // 路径详情

        // 2. Three.js核心对象初始化
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);

        // 相机：适配y轴为高度，设置水平视角
        const camera = new THREE.PerspectiveCamera(
            55,                  
            window.innerWidth / window.innerHeight,
            0.1,
            500000
        );
        camera.position.set(20000, 15000, 20000); // 调整为水平或稍高视角，避免从下往上看
        camera.lookAt(new THREE.Vector3(0, 70, 0)); // 看向场景中心

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 轨道控制器：限制相机角度，不允许从下方查看
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 5000;  
        controls.maxDistance = 100000;
        controls.target.set(0, 70, 0);
        controls.maxPolarAngle = Math.PI / 2; // 限制最大极角为90度（水平视角）

        // 3. 光照系统
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const spotLight = new THREE.SpotLight(0xffffff, 0.8);
        spotLight.position.set(20000, 20000, 20000); // 斜上方光源
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.set(2048, 2048);
        spotLight.shadow.camera.near = 100;
        spotLight.shadow.camera.far = 100000;
        scene.add(spotLight);

        // 4. 辅助元素
        const gridHelper = new THREE.GridHelper(100000, 50); // 地面网格：x/z平面
        gridHelper.position.y = 0; // 网格在y=0处（底层地面）
        gridHelper.material.opacity = 0.5;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);
        const axesHelper = new THREE.AxesHelper(10000); // 坐标轴：x红、y绿、z蓝
        scene.add(axesHelper);

        // 5. 工具函数：修正坐标映射（海拔→y轴）
        function lonlatTo3d(lon, lat, alt) {
            const x = (lon - minLon) * CONFIG.SCALE - 35000; // 经度→x轴（水平）
            const y = alt * CONFIG.ALTITUDE_SCALE - 60000;   // 海拔→y轴（垂直高度）
            const z = (lat - minLat) * CONFIG.SCALE - 15000; // 纬度→z轴（水平）
            return new THREE.Vector3(x, y, z);
        }

        // 统一使用灰色表示未选择的教室
        function getColorByAlt(alt) {
            return 0x999999; // 灰色
        }

        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="error提示">${text}</span>` : text;
        }

        // 6. 绘制函数

    function drawEdges() {
        const processed = new Set();
        for (const start in edges) {
            for (const end in edges[start]) {
                const key = `${start}-${end}`;
                const reverseKey = `${end}-${start}`;
                if (processed.has(key) || processed.has(reverseKey)) continue;
                processed.add(key);

                if (!nodes[start] || !nodes[end]) continue;

                // 计算拥挤度并设置颜色
                const edgeData = edges[start][end];
                const crowd = edgeData.actual_flow / edgeData.max_cap;
                let edgeColor;
                
                if (crowd < 0.5) {
                    edgeColor = 0x00cc00; // 绿色 - 畅通
                } else if (crowd <= 0.8) {
                    edgeColor = 0xffff00; // 黄色 - 拥挤
                } else {
                    edgeColor = 0xff0000; // 红色 - 堵塞
                }

                const sideRoadMat = new THREE.MeshLambertMaterial({
                    color: edgeColor,
                    transparent: true,
                    opacity: 0.8
                });

                const startPos = lonlatTo3d(
                    nodes[start].lon,
                    nodes[start].lat,
                    nodes[start].alt
                );
                const endPos = lonlatTo3d(
                    nodes[end].lon,
                    nodes[end].lat,
                    nodes[end].alt
                );

                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                const cylinderRadius = 80;
                const cylinderGeo = new THREE.CylinderGeometry(
                    cylinderRadius,
                    cylinderRadius,
                    length,
                    32
                );
    
                const cylinderMesh = new THREE.Mesh(cylinderGeo, sideRoadMat);
                cylinderMesh.position.copy(midPoint);
                cylinderMesh.lookAt(endPos);
                cylinderMesh.rotateX(Math.PI / 2);

                scene.add(cylinderMesh);
                edges[start][end].mesh = cylinderMesh;
                // 存储拥挤度信息用于路径计算
                edges[start][end].crowd = crowd;
            }
        }
        updateInfo(`已加载 ${processed.size} 条通道，楼层垂直分层显示`);
    }

        function drawNodes() {
            for (const id in nodes) {
                const node = nodes[id];
                const pos = lonlatTo3d(node.lon, node.lat, node.alt); // y轴为海拔
                const alt = node.alt;

                // 长方体几何体：x/z水平，y垂直（对应楼层高度）
                const boxGeo = new THREE.BoxGeometry(
                    CONFIG.BOX_SIZE.x,
                    CONFIG.BOX_SIZE.y,
                    CONFIG.BOX_SIZE.z
                );

                const materials = {
                    default: new THREE.MeshLambertMaterial({
                        color: getColorByAlt(alt),
                        transparent: false
                    }),
                    hover: new THREE.MeshLambertMaterial({
                        color: 0xeeeeaa,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3,
                        transparent: false
                    }),
                    start: new THREE.MeshLambertMaterial({
                        color: 0x00ff00,
                        transparent: false
                    }),
                    end: new THREE.MeshLambertMaterial({
                        color: 0x0000ff,
                        transparent: false
                    })
                };

                const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                boxMesh.position.copy(pos);
                boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                boxMesh.castShadow = true;
                boxMesh.receiveShadow = true;
                scene.add(boxMesh);

                nodes[id] = {
                    ...node,
                    mesh: boxMesh,
                    materials,
                    originalScale: new THREE.Vector3(1, 1, 1)
                };
            }
        }

        function drawPath(path, index, color) {
            // 根据路径索引设置颜色：第一条蓝色，第二条紫色
            const pathColors = [0x0000ff, 0x8800ff];
            const pathMat = new THREE.MeshLambertMaterial({
                color: pathColors[index] || color,
                transparent: true,
                opacity: 0.9
            });

            for(let i = 0; i < path.length - 1; i++) {
                const nodeId1 = path[i];
                const nodeId2 = path[i + 1];
                
                if (!nodes[nodeId1] || !nodes[nodeId2]) continue;

                const startPos = lonlatTo3d(
                    nodes[nodeId1].lon,
                    nodes[nodeId1].lat,
                    nodes[nodeId1].alt
                );
                const endPos = lonlatTo3d(
                    nodes[nodeId2].lon,
                    nodes[nodeId2].lat,
                    nodes[nodeId2].alt
                );

                const direction = new THREE.Vector3().subVectors(endPos, startPos);
                const length = direction.length();
                const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                const cylinderGeo = new THREE.CylinderGeometry(
                    CONFIG.PATH_WIDTH,
                    CONFIG.PATH_WIDTH,
                    length,
                    32
                );

                const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                cylinderMesh.position.copy(midPoint);
                cylinderMesh.lookAt(endPos);
                cylinderMesh.rotateX(Math.PI / 2);
                cylinderMesh.renderOrder = 10; // 确保路径显示在最上层
                scene.add(cylinderMesh);
                pathMeshes.push(cylinderMesh);
            }
        }

        // 7. 路径计算函数
        function calculateEdgeWeight(fromId, toId) {
            if (!edges[fromId] || !edges[fromId][toId]) return Infinity;
            
            const edge = edges[fromId][toId];
            const from = nodes[fromId];
            const to = nodes[toId];
            
            // 计算地理距离
            const lon1 = from.lon, lat1 = from.lat;
            const lon2 = to.lon, lat2 = to.lat;
            const geoDist = Math.sqrt(Math.pow(lon2 - lon1, 2) + Math.pow(lat2 - lat1, 2));
            
            // 道路类型系数
            const roadCoeff = edge.road_type === 'main' ? 1 : 1.2;
            
            // 海拔惩罚
            const altDiff = Math.abs(from.alt - to.alt);
            const altPenalty = altDiff > 0 ? altDiff * 0.1 : 0;
            
            // 拥挤度惩罚（指数级惩罚）
            const crowd = edge.crowd || (edge.actual_flow / edge.max_cap);
            // 使用指数函数增强对高拥挤度的惩罚，crowd越大惩罚越严重
            const crowdPenalty = crowd > 0 ? Math.exp(CONFIG.CONGESTION_PENALTY * crowd) : 1;
            
            // 总权重 = 基础权重 * 拥挤度惩罚
            return (geoDist * roadCoeff + altPenalty) * crowdPenalty;
        }

        function calculatePathWeight(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                total += calculateEdgeWeight(path[i], path[i + 1]);
            }
            return total;
        }

        function calculatePathLength(path) {
            let total = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const start = nodes[path[i]];
                const end = nodes[path[i + 1]];
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                total += Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }
            return total;
        }

        function dijkstra(startId, endId) {
            const distances = {};
            const predecessors = {};
            const unvisited = new Set(Object.keys(nodes));

            Object.keys(nodes).forEach(id => {
                distances[id] = Infinity;
                predecessors[id] = null;
            });
            distances[startId] = 0;

            while (unvisited.size > 0) {
                let currentId = null;
                let minDist = Infinity;
                for (const id of unvisited) {
                    if (distances[id] < minDist) {
                        minDist = distances[id];
                        currentId = id;
                    }
                }

                if (currentId === endId) break;
                if (minDist === Infinity) break;

                unvisited.delete(currentId);

                for (const neighborId in edges[currentId]) {
                    const weight = calculateEdgeWeight(currentId, neighborId);
                    if (weight === Infinity) continue;

                    const distance = distances[currentId] + weight;
                    if (distance < distances[neighborId]) {
                        distances[neighborId] = distance;
                        predecessors[neighborId] = currentId;
                    }
                }
            }

            // 重建路径
            const path = [];
            let current = endId;
            while (current !== null) {
                path.unshift(current);
                current = predecessors[current];
            }

            return path[0] === startId ? path : null;
        }

        function findKShortestPaths(startId, endId, k = 2) {
            const kPaths = [];
            // 找到第一条最短路径
            const firstPath = dijkstra(startId, endId);
            if (!firstPath) return [];
            
            kPaths.push(firstPath);
            
            for (let m = 1; m < k; m++) {
                let minWeight = Infinity;
                let bestPath = null;
                
                // 遍历前一条路径的每个节点，作为“偏离点”
                for (let i = 0; i < kPaths[m-1].length - 1; i++) {
                    const spurNode = kPaths[m-1][i];
                    const rootPath = kPaths[m-1].slice(0, i+1);

                    // 临时删除“偏离点之前的边”，避免重复路径
                    const removedEdges = new Map();
                    kPaths.forEach(path => {
                        if (path.slice(0, i+1).join(',') === rootPath.join(',')) {
                            const edgeKey = `${path[i]}-${path[i+1]}`;
                            if (edges[path[i]]?.[path[i+1]]) {
                                removedEdges.set(edgeKey, edges[path[i]][path[i+1]]);
                                delete edges[path[i]][path[i+1]];
                            }
                        }
                    });

                    // 找从“偏离点”到终点的最短路径（spur path）
                    const spurPath = dijkstra(spurNode, endId);
                    if (spurPath) {
                        const newPath = [...rootPath.slice(0, -1), ...spurPath];
                        // 路径去重
                        const isDuplicate = kPaths.some(existPath => 
                            existPath.length === newPath.length && 
                            existPath.every((node, idx) => node === newPath[idx])
                        );
                        
                        if (!isDuplicate) {
                            const pathWeight = calculatePathWeight(newPath);
                            if (pathWeight < minWeight) {
                                minWeight = pathWeight;
                                bestPath = newPath;
                            }
                        }
                    }

                    // 恢复删除的边
                    removedEdges.forEach((edge, key) => {
                        const [from, to] = key.split('-');
                        if (!edges[from]) edges[from] = {};
                        edges[from][to] = edge;
                    });
                }
                
                if (bestPath) {
                    kPaths.push(bestPath);
                } else {
                    break; // 找不到更多路径
                }
            }
            
            return kPaths;
        }

        // 8. 交互与主函数
        function clearPaths() {
            pathMeshes.forEach(mesh => scene.remove(mesh));
            pathMeshes = [];
            pathData = [];
            document.getElementById('path-detail').style.display = 'none';
        }

        function selectNode(nodeId) {
            if (selectedNodes.includes(nodeId)) return;
            
            // 重置之前选中的节点样式（保留起点和终点）
            if (selectedNodes.length === 0) {
                clearPaths();
                Object.values(nodes).forEach(node => {
                    node.mesh.material = node.materials.default;
                });
            }
            
            selectedNodes.push(nodeId);
            const node = nodes[nodeId];
            
            // 设置节点样式
            if (selectedNodes.length === 1) {
                node.mesh.material = node.materials.start;
                updateInfo('请选择终点（蓝色）');
            } else if (selectedNodes.length === 2) {
                node.mesh.material = node.materials.end;
                
                // 计算并显示路径
                const startId = selectedNodes[0];
                const endId = selectedNodes[1];
                const paths = findKShortestPaths(startId, endId, CONFIG.K);
                
                if (paths.length > 0) {
                    pathData = paths;
                    paths.forEach((path, index) => {
                        drawPath(path, index);
                    });
                    
                    // 显示路径详情
                    const pathDetail = document.getElementById('path-detail');
                    const path1El = document.getElementById('path1');
                    const path2El = document.getElementById('path2');
                    
                    path1El.innerHTML = `路径 1（长度: ${calculatePathLength(paths[0]).toFixed(2)}m）：<br>${paths[0].join(' → ')}`;
                    
                    if (paths.length > 1) {
                        path2El.innerHTML = `路径 2（长度: ${calculatePathLength(paths[1]).toFixed(2)}m）：<br>${paths[1].join(' → ')}`;
                    } else {
                        path2El.innerHTML = '';
                    }
                    
                    pathDetail.style.display = 'block';
                    updateInfo(`已找到 ${paths.length} 条路径`);
                } else {
                    updateInfo('无法找到路径', true);
                }
                
                // 重置选择，允许重新选择
                selectedNodes = [];
            }
        }

        // 初始化射线拾取器，用于点击选择节点
        function initRaycaster() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            function onMouseClick(event) {
                // 计算鼠标在标准化设备坐标中的位置 (-1 到 1)
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // 更新射线投射器
                raycaster.setFromCamera(mouse, camera);
                
                // 检查与所有节点的交集
                const intersects = raycaster.intersectObjects(
                    Object.values(nodes).map(node => node.mesh)
                );
                
                if (intersects.length > 0) {
                    const nodeId = intersects[0].object.userData.id;
                    selectNode(nodeId);
                }
            }
            
            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(
                    Object.values(nodes).map(node => node.mesh)
                );
                
                // 重置所有节点的悬停状态
                Object.values(nodes).forEach(node => {
                    if (node.mesh.material !== node.materials.start && 
                        node.mesh.material !== node.materials.end) {
                        node.mesh.material = node.materials.default;
                    }
                });
                
                // 设置悬停节点样式
                if (intersects.length > 0) {
                    const nodeId = intersects[0].object.userData.id;
                    const node = nodes[nodeId];
                    if (node.mesh.material !== node.materials.start && 
                        node.mesh.material !== node.materials.end) {
                        node.mesh.material = node.materials.hover;
                    }
                }
            }
            
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousemove', onMouseMove);
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // 加载数据并初始化
        async function init() {
            try {
                const response = await fetch('path_data.json');
                const data = await response.json();
                
                minLon = data.min_lon;
                minLat = data.min_lat;
                nodes = data.nodes;
                edges = data.edges;
                
                drawNodes();
                drawEdges();
                initRaycaster();
                animate();
            } catch (error) {
                console.error('数据加载失败:', error);
                updateInfo('数据加载失败，请刷新页面重试', true);
            }
        }

        // 启动应用
        init();
    </script>
</body>
</html>
