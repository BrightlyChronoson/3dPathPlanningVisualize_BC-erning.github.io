<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D路径规划可视化系统</title>
    <style>
        body { margin: 0; }
        #scene-container { position: absolute; width: 100%; height: 100%; }
        #path-detail { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.8); 
            padding: 10px; 
            border-radius: 5px; 
            font-size: 14px;
            z-index: 100;
        }
        #hint {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
    <!-- 引入Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="scene-container"></div>
    <div id="path-detail">路径详情：暂无</div>
    <div id="hint">点击第一个长方体作为起点（绿色），第二个作为终点（蓝色）</div>

    <script>
        // 1. 初始化Three.js核心对象
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);

        // 轨道控制器（支持鼠标交互旋转/缩放）
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.z = 30;
        controls.update();

        // 2. 定义场景数据（节点+边，边新增crowd拥挤度属性）
        // 节点：教室/空间，包含id、坐标(x,y,z)、名称
        const nodes = [
            { id: 1, x: 0, y: 0, z: 0, name: '教室101' },
            { id: 2, x: 5, y: 0, z: 0, name: '教室102' },
            { id: 3, x: 10, y: 0, z: 0, name: '走廊1' },
            { id: 4, x: 10, y: 0, z: 5, name: '教室103' },
            { id: 5, x: 10, y: 0, z: 10, name: '楼梯间' },
            { id: 6, x: 15, y: 0, z: 10, name: '教室104' },
        ];

        // 边：节点连接关系，新增crowd（拥挤度 0-1）属性
        const edges = [
            { from: 1, to: 2, crowd: 0.4 }, // 绿色
            { from: 2, to: 3, crowd: 0.6 }, // 黄色
            { from: 3, to: 4, crowd: 0.9 }, // 红色
            { from: 3, to: 5, crowd: 0.7 }, // 黄色
            { from: 5, to: 6, crowd: 0.3 }, // 绿色
        ];

        // 3. 绘制节点（长方体）
        const nodeMeshes = {}; // 存储节点mesh，方便后续交互
        function drawNodes() {
            const nodeGeometry = new THREE.BoxGeometry(2, 2, 2); // 长方体尺寸
            nodes.forEach(node => {
                const nodeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xcccccc, // 默认灰色
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(nodeGeometry, nodeMaterial);
                mesh.position.set(node.x, node.y, node.z);
                mesh.userData = { type: 'node', id: node.id }; // 存储节点ID
                scene.add(mesh);
                nodeMeshes[node.id] = mesh;

                // 鼠标悬停效果
                mesh.addEventListener('pointerover', () => {
                    mesh.material.color.set(0xffffcc); // 浅黄
                });
                mesh.addEventListener('pointerout', () => {
                    if (mesh.userData.role !== 'start' && mesh.userData.role !== 'end') {
                        mesh.material.color.set(0xcccccc); // 恢复灰色
                    }
                });
            });
        }

        // 4. 绘制边（核心修改1：根据拥挤度设置初始颜色）
        const edgeLines = []; // 存储边的线条对象
        function drawEdges() {
            edges.forEach(edge => {
                // 获取边的起点和终点坐标
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                // 根据拥挤度确定边的颜色
                let edgeColor;
                if (edge.crowd < 0.5) {
                    edgeColor = 0x00ff00; // 绿色：拥挤度<0.5
                } else if (edge.crowd <= 0.8) {
                    edgeColor = 0xffff00; // 黄色：0.5-0.8
                } else {
                    edgeColor = 0xff0000; // 红色：>0.8
                }

                // 创建边的线条
                const points = [
                    new THREE.Vector3(fromNode.x, fromNode.y, fromNode.z),
                    new THREE.Vector3(toNode.x, toNode.y, toNode.z)
                ];
                const edgeGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const edgeMaterial = new THREE.LineBasicMaterial({ 
                    color: edgeColor,
                    linewidth: 2 // 线条宽度
                });
                const line = new THREE.Line(edgeGeometry, edgeMaterial);
                line.userData = { type: 'edge', from: edge.from, to: edge.to, crowd: edge.crowd };
                scene.add(line);
                edgeLines.push(line);
            });
        }

        // 5. 权重计算函数（核心修改2：拥挤度指数级惩罚）
        function calculateEdgeWeight(edge) {
            const fromNode = nodes.find(n => n.id === edge.from);
            const toNode = nodes.find(n => n.id === edge.to);
            
            // 基础地理距离（欧几里得距离）
            const distance = Math.sqrt(
                Math.pow(toNode.x - fromNode.x, 2) +
                Math.pow(toNode.y - fromNode.y, 2) +
                Math.pow(toNode.z - fromNode.z, 2)
            );

            // 道路系数（示例固定值，可扩展）
            const roadFactor = 1.0;

            // 海拔惩罚（示例简化为0，可扩展）
            const elevationPenalty = 0;

            // 核心修改：拥挤度指数级惩罚（exp(5*crowd) - 1 确保0拥挤度时惩罚为0）
            // 系数5可调整，越大惩罚越剧烈
            const crowdPenalty = Math.exp(5 * edge.crowd) - 1;

            // 总权重 = 基础距离 * 道路系数 + 海拔惩罚 + 拥挤度惩罚
            const totalWeight = distance * roadFactor + elevationPenalty + crowdPenalty;
            return totalWeight;
        }

        // 6. Dijkstra算法（计算单条最短路径）
        function dijkstra(startId, endId) {
            // 初始化距离表
            const distances = {};
            const previous = {};
            const unvisited = new Set();

            nodes.forEach(node => {
                distances[node.id] = Infinity;
                previous[node.id] = null;
                unvisited.add(node.id);
            });
            distances[startId] = 0;

            while (unvisited.size > 0) {
                // 找到未访问节点中距离最小的
                let currentId = [...unvisited].reduce((minId, id) => {
                    return distances[id] < distances[minId] ? id : minId;
                });

                if (currentId === endId) break; // 到达终点，提前退出

                unvisited.delete(currentId);

                // 遍历当前节点的所有邻边
                const adjacentEdges = edges.filter(edge => 
                    edge.from === currentId || edge.to === currentId
                );

                adjacentEdges.forEach(edge => {
                    const neighborId = edge.from === currentId ? edge.to : edge.from;
                    if (!unvisited.has(neighborId)) return;

                    // 计算新距离
                    const edgeWeight = calculateEdgeWeight(edge);
                    const newDistance = distances[currentId] + edgeWeight;

                    if (newDistance < distances[neighborId]) {
                        distances[neighborId] = newDistance;
                        previous[neighborId] = currentId;
                    }
                });
            }

            // 回溯路径
            const path = [];
            let current = endId;
            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }

            return {
                path: path[0] === startId ? path : [], // 确保路径有效
                totalWeight: distances[endId]
            };
        }

        // 7. 计算多条最短路径（K=2）
        function getKShortestPaths(startId, endId, K = 2) {
            const paths = [];
            let currentPath = dijkstra(startId, endId);
            
            if (currentPath.path.length === 0) return paths; // 无有效路径
            
            paths.push(currentPath);
            
            // 简单实现：移除第一条路径的核心边，计算第二条路径（可扩展更优策略）
            if (K > 1 && currentPath.path.length > 1) {
                // 临时移除第一条路径的第一条边
                const tempRemovedEdges = [];
                for (let i = 0; i < currentPath.path.length - 1; i++) {
                    const edgeIndex = edges.findIndex(e => 
                        (e.from === currentPath.path[i] && e.to === currentPath.path[i+1]) ||
                        (e.to === currentPath.path[i] && e.from === currentPath.path[i+1])
                    );
                    if (edgeIndex !== -1) {
                        tempRemovedEdges.push(edges.splice(edgeIndex, 1)[0]);
                    }
                }
                
                // 计算第二条路径
                const secondPath = dijkstra(startId, endId);
                if (secondPath.path.length > 0) {
                    paths.push(secondPath);
                }
                
                // 恢复移除的边
                edges.push(...tempRemovedEdges);
            }
            
            return paths;
        }

        // 8. 绘制路径
        function drawPath(path, color) {
            if (path.length < 2) return;

            // 创建路径点
            const points = path.map(nodeId => {
                const node = nodes.find(n => n.id === nodeId);
                return new THREE.Vector3(node.x, node.y, node.z);
            });

            // 绘制路径线条
            const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const pathMaterial = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 3,
                transparent: true,
                opacity: 0.9
            });
            const pathLine = new THREE.Line(pathGeometry, pathMaterial);
            scene.add(pathLine);
            return pathLine;
        }

        // 9. 交互逻辑：选择起点和终点
        let startId = null;
        let endId = null;
        let pathLines = []; // 存储已绘制的路径

        // 射线检测（实现鼠标点击选择节点）
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerClick(event) {
            // 转换鼠标坐标到Three.js坐标系
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(Object.values(nodeMeshes));

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                const nodeId = clickedMesh.userData.id;

                // 选择起点
                if (startId === null) {
                    startId = nodeId;
                    clickedMesh.userData.role = 'start';
                    clickedMesh.material.color.set(0x00ff00); // 绿色
                    document.getElementById('hint').textContent = '已选起点：' + nodes.find(n => n.id === startId).name + '，请选择终点（蓝色）';
                } 
                // 选择终点
                else if (endId === null && nodeId !== startId) {
                    endId = nodeId;
                    clickedMesh.userData.role = 'end';
                    clickedMesh.material.color.set(0x0000ff); // 蓝色
                    document.getElementById('hint').textContent = '已选终点：' + nodes.find(n => n.id === endId).name + '，正在计算路径...';

                    // 计算并绘制多条路径
                    const kPaths = getKShortestPaths(startId, endId);
                    
                    // 清空原有路径
                    pathLines.forEach(line => scene.remove(line));
                    pathLines = [];

                    // 绘制路径（第一条红，第二条紫）
                    let pathDetail = '';
                    kPaths.forEach((pathObj, index) => {
                        if (pathObj.path.length === 0) return;
                        
                        const color = index === 0 ? 0xff0000 : 0x9900ff;
                        const pathLine = drawPath(pathObj.path, color);
                        pathLines.push(pathLine);

                        // 计算路径长度
                        const pathLength = calculatePathLength(pathObj.path);
                        pathDetail += `路径${index+1}：${pathObj.path.map(id => nodes.find(n => n.id === id).name).join(' → ')}，总权重：${pathObj.totalWeight.toFixed(2)}，实际长度：${pathLength.toFixed(2)}<br>`;
                    });

                    document.getElementById('path-detail').innerHTML = `路径详情：<br>${pathDetail || '无有效路径'}`;
                    document.getElementById('hint').textContent = '路径计算完成，可重新点击选择起点/终点';
                } 
                // 重置选择
                else {
                    startId = nodeId;
                    endId = null;
                    
                    // 重置所有节点颜色
                    Object.values(nodeMeshes).forEach(mesh => {
                        mesh.userData.role = null;
                        mesh.material.color.set(0xcccccc);
                    });
                    
                    // 清空路径
                    pathLines.forEach(line => scene.remove(line));
                    pathLines = [];
                    
                    clickedMesh.userData.role = 'start';
                    clickedMesh.material.color.set(0x00ff00);
                    document.getElementById('hint').textContent = '已重置起点：' + nodes.find(n => n.id === startId).name + '，请选择终点（蓝色）';
                    document.getElementById('path-detail').textContent = '路径详情：暂无';
                }
            }
        }

        // 计算路径实际长度（无惩罚，纯地理距离）
        function calculatePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const fromNode = nodes.find(n => n.id === path[i]);
                const toNode = nodes.find(n => n.id === path[i+1]);
                length += Math.sqrt(
                    Math.pow(toNode.x - fromNode.x, 2) +
                    Math.pow(toNode.y - fromNode.y, 2) +
                    Math.pow(toNode.z - fromNode.z, 2)
                );
            }
            return length;
        }

        // 监听鼠标点击事件
        window.addEventListener('click', onPointerClick);

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 渲染循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新轨道控制器
            renderer.render(scene, camera);
        }

        // 初始化场景
        drawNodes();
        drawEdges(); // 绘制边（已按拥挤度上色）
        animate();
    </script>
</body>
</html>

