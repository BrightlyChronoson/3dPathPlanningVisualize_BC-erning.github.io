<!DOCTYPE html>
<html>
<head>
    <title>3Dè·¯å¾„è§„åˆ’ç³»ç»Ÿï¼ˆä»…æ—‹è½¬ç‰ˆï¼‰</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Arial', sans-serif; }
        #info-panel { 
            position: absolute; top: 10px; left: 10px; 
            background: rgba(255,255,255,0.9); padding: 12px 15px; 
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 14px; color: #333; z-index: 100;
        }
        #mode-panel {
            position: absolute; top: 10px; left: 280px;
            background: rgba(255,255,255,0.9); padding: 10px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 100;
            cursor: move; 
        }
        .mode-btn {
            padding: 6px 12px; margin: 0 5px;
            border: 1px solid #ccc; border-radius: 4px;
            background: #f5f5f5; cursor: pointer; font-size: 13px;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: #007bff; color: white; border-color: #007bff;
        }
        .mode-btn:hover { background: #e9ecef; }
        .mode-btn.active:hover { background: #0069d9; }
        #path-detail {
            position: absolute; top: 70px; left: 10px;
            background: rgba(255,255,255,0.9); padding: 12px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px; color: #333; display: none; z-index: 100;
            cursor: move; 
        }
        #search-panel {
            cursor: move !important; /* è¦†ç›–å†…è”æ ·å¼ */
        }
        .legend {
            position: absolute; top: 10px; right: 10px;
            background: rgba(255,255,255,0.9); padding: 12px 15px;
            border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px; color: #333; z-index: 100;
        }
        .legend-item {
            display: flex; align-items: center; margin: 6px 0;
        }
        .legend-color {
            width: 16px; height: 16px; margin-right: 8px; border-radius: 3px;
        }
        .error-tip { color: #dc3545; font-weight: bold; }
        .css2d-label {
            transition: transform 0.2s ease;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>
    <div id="info-panel">ç‚¹å‡»ç¬¬ä¸€ä¸ªé•¿æ–¹ä½“ä½œä¸ºèµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰ï¼Œç¬¬äºŒä¸ªä½œä¸ºç»ˆç‚¹ï¼ˆè“è‰²ï¼‰</div>
    <div id="mode-panel">
        <span style="font-size:13px; font-weight:bold; margin-right:8px;">é€‰æ‹©æ¨¡å¼ï¼š</span>
        <button class="mode-btn active" data-mode="teaching">æ•™å­¦æ¥¼æ¨¡å¼</button>
        <button class="mode-btn" data-mode="campus">æ ¡å›­æ¨¡å¼</button>
    </div>
    <div id="path-detail">
        <div style="font-weight: bold; margin-bottom: 5px;">è·¯å¾„è¯¦æƒ…</div>
        <div id="path1"></div>
        <div id="path2" style="margin-top: 8px;"></div>
    </div>
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">å›¾ä¾‹</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #999999;"></div>
            <span id="legend-node-text">æ•™å®¤</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eeeeaa;"></div>
            <span>æ‚¬åœç›®æ ‡</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>èµ·ç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>ç»ˆç‚¹</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #006600;"></div>
            <span>è¿æ¥é€šé“</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #0000ff;"></div>
            <span>ç¬¬1æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8800ff;"></div>
            <span>ç¬¬2æ¡æœ€çŸ­è·¯å¾„</span>
        </div>
    </div>

    <div id="search-panel" style="position: absolute; top: 220px; left: 10px; background: rgba(255,255,255,0.9); padding: 12px 15px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 100;">
        <div style="font-weight: bold; margin-bottom: 8px; font-size: 13px;">èŠ‚ç‚¹æŸ¥æ‰¾ï¼ˆç›´æ¥è®¾ç½®èµ·/ç»ˆç‚¹ï¼‰</div>
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <div style="flex: 1;">
                <label style="font-size: 12px; color: #666;">èµ·ç‚¹ï¼š</label>
                <input type="text" id="start-node-input" placeholder="è¾“å…¥èŠ‚ç‚¹åï¼ˆå¦‚æ•™å®¤101ï¼‰" style="width: 100%; padding: 4px 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-top: 4px;">
            </div>
            <div style="flex: 1;">
                <label style="font-size: 12px; color: #666;">ç»ˆç‚¹ï¼š</label>
                <input type="text" id="end-node-input" placeholder="è¾“å…¥èŠ‚ç‚¹åï¼ˆå¦‚æ•™å®¤102ï¼‰" style="width: 100%; padding: 4px 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-top: 4px;">
            </div>
        </div>
        <button id="search-path-btn" style="padding: 5px 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">è®¡ç®—è·¯å¾„</button>
        <div id="search-tip" style="margin-top: 6px; font-size: 12px; color: #dc3545; display: none;"></div>
    </div>
    
    <script>
        // ===================== å…¨å±€åŸºç¡€å±‚ï¼ˆå…±äº«ï¼‰ =====================
        let cameraPosition = { x: 20000, y: 15000, z: 20000 }; 

        // ===================== é€šç”¨èŠ‚æµå‡½æ•° =====================
        function throttle(func, delay) {
            let lastExecuteTime = 0;
            let timeoutId = null;
            return function(...args) {
                const now = Date.now();
                if (now - lastExecuteTime >= delay) {
                    func.apply(this, args);
                    lastExecuteTime = now;
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                        lastExecuteTime = Date.now();
                    }, delay);
                }
            };
        }

        // ===================== ç›¸æœºæ§åˆ¶é…ç½®ï¼ˆä»…ä¿ç•™æ—‹è½¬ï¼‰ =====================
        const CAMERA_CONFIG = {
            rotateSpeed: 0.01,    // å¹³ç¼“çš„æ—‹è½¬é€Ÿåº¦
            maxPolarAngle: Math.PI / 2 - 0.1, // é˜²æ­¢ç›¸æœºç¿»å€’
            minPolarAngle: 0.1,
            throttleDelay: 30     // é•¿æŒ‰è§¦å‘é—´éš”
        };

        // å­˜å‚¨æŒ‰é”®çŠ¶æ€
        const pressedKeys = {};
        
        // Three.jsæ ¸å¿ƒå¯¹è±¡
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        
        // å…¨å±€çŠ¶æ€
        let currentModeInstance = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNodeId = null;
        let labelRenderer;

        // ===================== é¢æ¿æ‹–æ‹½å‡½æ•° =====================
        function makePanelDraggable(panelElement) {
            if (!panelElement) return;
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            panelElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = parseInt(window.getComputedStyle(panelElement).left) || 0;
                initialTop = parseInt(window.getComputedStyle(panelElement).top) || 0;
                panelElement.style.userSelect = 'none';
                panelElement.style.zIndex = 200;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const offsetX = e.clientX - startX;
                const offsetY = e.clientY - startY;
                panelElement.style.left = `${initialLeft + offsetX}px`;
                panelElement.style.top = `${initialTop + offsetY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    panelElement.style.userSelect = '';
                    panelElement.style.zIndex = 100;
                }
            });
        }
        
        // ===================== ç›¸æœºæ—‹è½¬å‡½æ•°ï¼ˆä»…ä¿ç•™æ—‹è½¬ï¼‰ =====================
        function rotateCamera(direction) {
            if (!controls) return;
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(new THREE.Vector3().subVectors(camera.position, controls.target));

            // å·¦å³æ—‹è½¬ï¼ˆç»•Yè½´ï¼‰
            if (direction === 'left') {
                spherical.theta += CAMERA_CONFIG.rotateSpeed;
            } else if (direction === 'right') {
                spherical.theta -= CAMERA_CONFIG.rotateSpeed;
            }

            // ä¸Šä¸‹æ—‹è½¬ï¼ˆç»•Xè½´ï¼Œé™åˆ¶è§’åº¦ï¼‰
            if (direction === 'up') {
                spherical.phi = Math.max(CAMERA_CONFIG.minPolarAngle, spherical.phi - CAMERA_CONFIG.rotateSpeed);
            } else if (direction === 'down') {
                spherical.phi = Math.min(CAMERA_CONFIG.maxPolarAngle, spherical.phi + CAMERA_CONFIG.rotateSpeed);
            }

            // åº”ç”¨æ–°ä½ç½®
            camera.position.setFromSpherical(spherical).add(controls.target);
            camera.lookAt(controls.target);
            controls.update();
        }

        // èŠ‚æµåŒ…è£…æ—‹è½¬å‡½æ•°
        const throttledRotate = throttle(rotateCamera, CAMERA_CONFIG.throttleDelay);

        // ===================== å…¨å±€é”®ç›˜äº‹ä»¶ï¼ˆä»…å¤„ç†æ—‹è½¬å’ŒESCï¼‰ =====================
        window.addEventListener('keydown', (e) => {
            pressedKeys[e.key] = true;
            
            // é˜»æ­¢æ–¹å‘é”®é»˜è®¤æ»šåŠ¨è¡Œä¸º
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }

            // ESCé”®æ¸…ç©ºè·¯å¾„
            if (e.key === 'Escape') { 
                clearSelectedPath();
            }
        });

        window.addEventListener('keyup', (e) => {
            pressedKeys[e.key] = false;
        });

        // ===================== åˆå§‹åŒ–å…¨å±€Three.jsç¯å¢ƒ =====================
        function initGlobalScene() {
            // å¤©ç©ºèƒŒæ™¯
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 256; skyCanvas.height = 256;
            const skyCtx = skyCanvas.getContext('2d');
            const skyGrad = skyCtx.createLinearGradient(0, 0, 0, 256);
            skyGrad.addColorStop(0, '#E0F7FF');
            skyGrad.addColorStop(1, '#87CEEB');
            skyCtx.fillStyle = skyGrad;
            skyCtx.fillRect(0, 0, 256, 256);
            scene.background = new THREE.CanvasTexture(skyCanvas);

            // ç›¸æœºé…ç½®
            camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
            camera.lookAt(new THREE.Vector3(0, 70, 0));

            // æ¸²æŸ“å™¨é…ç½®
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // æ ‡ç­¾æ¸²æŸ“å™¨
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);
            
            // æ§åˆ¶å™¨é…ç½®ï¼ˆå…³é—­è‡ªå¸¦é”®ç›˜æ§åˆ¶ï¼‰
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 5000;
            controls.maxDistance = 100000;
            controls.target.set(0, 70, 0);
            controls.maxPolarAngle = Math.PI / 2;
            controls.enableKeys = false; // å…³é—­OrbitControlsè‡ªå¸¦é”®ç›˜æ§åˆ¶

            // å…¨å±€å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50000, 80000, 50000);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 200000;
            dirLight.shadow.camera.left = -50000;
            dirLight.shadow.camera.right = 50000;
            dirLight.shadow.camera.top = 50000;
            dirLight.shadow.camera.bottom = -50000;
            scene.add(dirLight);

            // å…¨å±€åœ°æ¿
            const floorGeometry = new THREE.PlaneGeometry(300000, 300000);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xf0f0f0, roughness: 0.8, metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);

            // çª—å£è‡ªé€‚åº”
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
            });

            // åŠ¨ç”»å¾ªç¯ï¼ˆä»…å¤„ç†æ—‹è½¬ï¼‰
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
                labelRenderer.render(scene, camera);

                // æ ‡ç­¾å¤§å°éšç›¸æœºè·ç¦»è°ƒæ•´
                const distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
                const scale = Math.max(0.5, 2 - distance / 50000);
                document.querySelectorAll('.css2d-label').forEach(el => {
                    el.style.transform = `${el.style.transform} scale(${scale})`;
                    el.style.transformOrigin = 'center';
                });

                // ä»…å¤„ç†æ–¹å‘é”®æ—‹è½¬ï¼ˆæ— ä»»ä½•ç§»åŠ¨é€»è¾‘ï¼‰
                if (pressedKeys['ArrowUp']) throttledRotate('up');
                if (pressedKeys['ArrowDown']) throttledRotate('down');
                if (pressedKeys['ArrowLeft']) throttledRotate('left');
                if (pressedKeys['ArrowRight']) throttledRotate('right');
            }
            animate();
        }

        // ===================== å…¨å±€å·¥å…·å‡½æ•° =====================
        function updateInfo(text, isError = false) {
            const panel = document.getElementById('info-panel');
            panel.innerHTML = isError ? `<span class="error-tip">${text}</span>` : text;
        }

        function clearSelectedPath() {
            if (!currentModeInstance) return;

            // æ¢å¤èŠ‚ç‚¹æè´¨å’Œç¼©æ”¾
            currentModeInstance.selectedNodes.forEach(id => {
                const node = currentModeInstance.nodes[id];
                if (node) {
                    node.mesh.material = node.materials.default;
                    node.mesh.scale.copy(node.originalScale);
                }
            });

            // ç§»é™¤è·¯å¾„ç½‘æ ¼
            currentModeInstance.pathMeshes.forEach(mesh => scene.remove(mesh));
            currentModeInstance.pathMeshes = [];

            // é‡ç½®çŠ¶æ€
            currentModeInstance.selectedNodes = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';
            hoveredNodeId = null;
            updateInfo(`ç‚¹å‡»ç¬¬ä¸€ä¸ªé•¿æ–¹ä½“ä½œä¸ºèµ·ç‚¹ï¼ˆç»¿è‰²ï¼‰ï¼Œç¬¬äºŒä¸ªä½œä¸ºç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
        }
        
        // ===================== æ¨¡å¼åŸºç±» =====================
        class BaseMode {
            constructor(modeName, config, dataFile) {
                this.modeName = modeName;
                this.config = config;
                this.dataFile = dataFile;

                // æ¨¡å¼ç§æœ‰èµ„æº
                this.nodes = {};
                this.edges = {};
                this.selectedNodes = [];
                this.pathMeshes = [];
                this.nodeMeshes = [];
                this.edgeMeshes = [];
                this.minLon = 0;
                this.minLat = 0;
            }

            // åæ ‡è½¬æ¢
            lonlatTo3d(lon, lat, alt) {
                const x = (lon - this.minLon) * this.config.SCALE + this.config.X_OFFSET;
                const y = alt * this.config.ALTITUDE_SCALE + this.config.Y_OFFSET;
                const z = (this.minLat - lat) * this.config.SCALE + this.config.Z_OFFSET;
                return new THREE.Vector3(x, y, z);
            }

            // è°ƒæ•´ç›¸æœºä½ç½®
            adjustCamera() {
                if (this.modeName === 'campus') {
                    cameraPosition = { x: 80000, y: 40000, z: 80000 };
                } else {
                    cameraPosition = { x: 20000, y: 15000, z: 20000 };
                }
                camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
                camera.lookAt(new THREE.Vector3(0, 1000, 0));
                controls.target.set(0, 1000, 0);
            }

            // é”€æ¯å½“å‰æ¨¡å¼èµ„æº
            destroy() {
                // ç§»é™¤3Då…ƒç´ 
                this.pathMeshes.forEach(mesh => scene.remove(mesh));
                this.nodeMeshes.forEach(mesh => scene.remove(mesh));
                this.edgeMeshes.forEach(mesh => scene.remove(mesh));

                if (labelRenderer) {
                    labelRenderer.domElement.innerHTML = '';
                }
                
                // é‡ç½®çŠ¶æ€
                this.nodes = {};
                this.edges = {};
                this.selectedNodes = [];
                this.pathMeshes = [];
                this.nodeMeshes = [];
                this.edgeMeshes = [];
                this.minLon = 0;
                this.minLat = 0;
                document.getElementById('path-detail').style.display = 'none';
                document.getElementById('path1').innerHTML = '';
                document.getElementById('path2').innerHTML = '';
                hoveredNodeId = null;
            }

            // åŠ è½½æ¨¡å¼æ•°æ®
            loadData() {
                updateInfo(`æ­£åœ¨åŠ è½½${this.modeName === 'teaching' ? 'æ•™å­¦æ¥¼' : 'æ ¡å›­'}æ¨¡å¼æ•°æ®...`);
                fetch(this.dataFile)
                    .then(response => {
                        if (!response.ok) throw new Error(`æ•°æ®åŠ è½½å¤±è´¥ï¼ˆ${response.status}ï¼‰`);
                        return response.json();
                    })
                    .then(data => {
                        this.minLon = data.min_lon;
                        this.minLat = data.min_lat;
                        this.nodes = data.nodes;
                        this.edges = data.edges;
                        if (!this.nodes || Object.keys(this.nodes).length === 0) throw new Error("èŠ‚ç‚¹æ•°æ®ä¸ºç©º");
                        if (!this.edges || Object.keys(this.edges).length === 0) throw new Error("è¾¹æ•°æ®ä¸ºç©º");
                        this.drawEdges();
                        this.drawNodes();
                        this.adjustCamera();
                        document.getElementById('legend-node-text').innerText = this.modeName === 'teaching' ? 'æ•™å®¤' : 'å»ºç­‘';
                        updateInfo(`âœ… ${this.modeName === 'teaching' ? 'æ•™å­¦æ¥¼' : 'æ ¡å›­'}æ¨¡å¼åŠ è½½å®Œæˆï¼Œç‚¹å‡»é€‰æ‹©èµ·ç‚¹`);
                    })
                    .catch(error => {
                        updateInfo(`âš ï¸ åŠ è½½å¤±è´¥ï¼š${error.message}`, true);
                        if (error.message.includes('404')) {
                            updateInfo(`âš ï¸ æœªæ‰¾åˆ°${this.dataFile}ï¼ˆè¯·ç¡®ä¿ä¸index.htmlåŒç›®å½•ï¼‰`, true);
                        }
                    });
            }

            // ç»˜åˆ¶è¾¹
            drawEdges() {
                const processed = new Set();
                for (const start in this.edges) {
                    for (const end in this.edges[start]) {
                        const key = `${start}-${end}`;
                        const reverseKey = `${end}-${start}`;
                        if (processed.has(key) || processed.has(reverseKey)) continue;
                        processed.add(key);
                        if (!this.nodes[start] || !this.nodes[end]) continue;

                        // æ‹¥æŒ¤åº¦é¢œè‰²
                        const edgeData = this.edges[start][end];
                        const crowd = edgeData.max_cap === 0 ? 0 : Math.min(Math.max(edgeData.actual_flow / edgeData.max_cap, 0), 1);
                        let edgeColor = crowd < 0.5 ? 0x006600 : (crowd <= 0.8 ? 0xffff00 : 0xff0000);

                        // æè´¨
                        const sideRoadMat = new THREE.MeshStandardMaterial({
                            color: edgeColor, roughness: 0.7, metalness: 0.1,
                            transparent: true, opacity: 0.8
                        });

                        // åæ ‡è®¡ç®—
                        const startPos = this.lonlatTo3d(this.nodes[start].lon, this.nodes[start].lat, this.nodes[start].alt);
                        const endPos = this.lonlatTo3d(this.nodes[end].lon, this.nodes[end].lat, this.nodes[end].alt);
                        const direction = new THREE.Vector3().subVectors(endPos, startPos);
                        const length = direction.length();
                        const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                        // é€šé“å‡ ä½•ä½“
                        const cylinderGeo = new THREE.CylinderGeometry(
                            this.config.EDGE_RADIUS,
                            this.config.EDGE_RADIUS,
                            length,
                            32
                        );

                        const cylinderMesh = new THREE.Mesh(cylinderGeo, sideRoadMat);
                        cylinderMesh.position.copy(midPoint);
                        cylinderMesh.lookAt(endPos);
                        cylinderMesh.rotateX(Math.PI / 2);
                        scene.add(cylinderMesh);
                        this.edges[start][end].mesh = cylinderMesh;
                        this.edgeMeshes.push(cylinderMesh);
                    }
                }
            }

            // ç»˜åˆ¶èŠ‚ç‚¹
            drawNodes() {
                for (const id in this.nodes) {
                    const node = this.nodes[id];
                    const pos = this.lonlatTo3d(node.lon, node.lat, node.alt);
                    const alt = node.alt;

                    // èŠ‚ç‚¹å‡ ä½•ä½“
                    const boxGeo = new THREE.BoxGeometry(
                        this.config.BOX_SIZE.x,
                        this.config.BOX_SIZE.y,
                        this.config.BOX_SIZE.z
                    );

                    // æè´¨
                    const baseColor = 0x999999;
                    const materials = {
                        default: new THREE.MeshStandardMaterial({ 
                            color: baseColor, roughness: 0.7, metalness: 0.1,
                            emissive: 0x000000, emissiveIntensity: 0
                        }),
                        hover: new THREE.MeshStandardMaterial({ 
                            color: baseColor, roughness: 0.7, metalness: 0.1,
                            emissive: 0xffff00, emissiveIntensity: 0.5
                        }),
                        start: new THREE.MeshStandardMaterial({ 
                            color: 0x4CAF50, roughness: 0.7, metalness: 0.2,
                            emissive: 0x00ff00, emissiveIntensity: 0.3
                        }),
                        end: new THREE.MeshStandardMaterial({ 
                            color: 0x0000ff, roughness: 0.7, metalness: 0.2,
                            emissive: 0x0000ff, emissiveIntensity: 0.3
                        })
                    };

                    const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                    boxMesh.position.copy(pos);
                    boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    scene.add(boxMesh);
                    this.nodeMeshes.push(boxMesh);

                    // èŠ‚ç‚¹æ ‡ç­¾
                    const labelDiv = document.createElement('div');
                    labelDiv.classList.add('css2d-label');
                    labelDiv.style.fontSize = '12px';
                    labelDiv.style.fontWeight = 'bold';
                    labelDiv.style.color = id.includes('STAIR') || id.includes('CROSS') || id.includes('TURN') ? '#ffd070' : '#333';
                    labelDiv.style.background = 'rgba(255,255,255,0.8)';
                    labelDiv.style.padding = '2px 6px';
                    labelDiv.style.borderRadius = '3px';
                    labelDiv.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
                    labelDiv.textContent = id;

                    const label = new THREE.CSS2DObject(labelDiv);
                    label.position.set(0, this.config.BOX_SIZE.y / 2 + 200, 0);
                    boxMesh.add(label);
                    
                    this.nodes[id] = {
                        ...node,
                        mesh: boxMesh,
                        materials,
                        originalScale: new THREE.Vector3(1, 1, 1)
                    };
                }
            }

            // è®¡ç®—è¾¹æƒé‡ï¼ˆå­ç±»å¿…é¡»è¦†å†™ï¼‰
            calculateEdgeWeight(startId, endId) {
                throw new Error("å­ç±»å¿…é¡»å®ç°calculateEdgeWeightæ–¹æ³•");
            }

            // ç»˜åˆ¶è·¯å¾„
            drawPath(path, index, color) {
                const pathMat = new THREE.MeshStandardMaterial({
                    color: color, roughness: 0.7, metalness: 0.1,
                    transparent: true, opacity: 0.9
                });

                for (let i = 0; i < path.length - 1; i++) {
                    const nodeId1 = path[i];
                    const nodeId2 = path[i + 1];
                    const startPos = this.nodes[nodeId1].mesh.position.clone();
                    const endPos = this.nodes[nodeId2].mesh.position.clone();

                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    const midPoint = new THREE.Vector3().addVectors(startPos, endPos).divideScalar(2);

                    // è·¯å¾„å‡ ä½•ä½“
                    const cylinderGeo = new THREE.CylinderGeometry(
                        this.config.PATH_RADIUS,
                        this.config.PATH_RADIUS,
                        length,
                        32
                    );

                    const cylinderMesh = new THREE.Mesh(cylinderGeo, pathMat);
                    cylinderMesh.position.copy(midPoint);
                    cylinderMesh.lookAt(endPos);
                    cylinderMesh.rotateX(Math.PI / 2);
                    scene.add(cylinderMesh);
                    this.pathMeshes.push(cylinderMesh);
                }

                // è·¯å¾„è¯¦æƒ…
                const weight = this.calculatePathWeight(path);
                const length = this.calculatePathLength(path);
                const pathEl = document.getElementById(`path${index}`);
                pathEl.innerHTML = `
                    <div style="font-weight: bold;">ç¬¬${index}æ¡æœ€çŸ­è·¯å¾„</div>
                    <div>${this.modeName === 'teaching' ? 'æ•™å®¤' : 'å»ºç­‘'}åºåˆ—ï¼š${path.join(' â†’ ')}</div>
                    <div>é€šé“æ€»é•¿ï¼š${length.toFixed(2)} ç±³</div>
                    <div>ç»¼åˆæƒé‡ï¼š${weight.toFixed(2)}</div>
                `;
                document.getElementById('path-detail').style.display = 'block';
            }

            // è®¡ç®—è·¯å¾„æ€»æƒé‡
            calculatePathWeight(path) {
                let total = 0;
                for (let i = 0; i < path.length - 1; i++) {
                    total += this.calculateEdgeWeight(path[i], path[i + 1]);
                }
                return total;
            }

            // è®¡ç®—è·¯å¾„é•¿åº¦
            calculatePathLength(path) {
                let total = 0;
                for (let i = 0; i < path.length - 1; i++) {
                    const start = this.nodes[path[i]];
                    const end = this.nodes[path[i + 1]];
                    const x1 = start.lon * 111000;
                    const y1 = start.lat * 111000;
                    const x2 = end.lon * 111000;
                    const y2 = end.lat * 111000;
                    const planeDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const altDiff = end.alt - start.alt;
                    const altDist = Math.abs(altDiff);
                    const spaceDist = Math.sqrt(Math.pow(planeDist, 2) + Math.pow(altDist, 2));
                    total += spaceDist;
                }
                return total;
            }

            // Dijkstraç®—æ³•
            dijkstra(startId, endId) {
                const distances = {};
                const predecessors = {};
                const unvisited = new Set(Object.keys(this.nodes));
                Object.keys(this.nodes).forEach(id => {
                    distances[id] = Infinity;
                    predecessors[id] = null;
                });
                distances[startId] = 0;

                while (unvisited.size > 0) {
                    let currentId = null;
                    let minDist = Infinity;
                    for (const id of unvisited) {
                        if (distances[id] < minDist) {
                            minDist = distances[id];
                            currentId = id;
                        }
                    }
                    if (currentId === null || currentId === endId) break;
                    unvisited.delete(currentId);

                    for (const neighborId in this.edges[currentId]) {
                        if (!unvisited.has(neighborId)) continue;
                        const newDist = distances[currentId] + this.calculateEdgeWeight(currentId, neighborId);
                        if (newDist < distances[neighborId]) {
                            distances[neighborId] = newDist;
                            predecessors[neighborId] = currentId;
                        }
                    }
                }

                const path = [];
                let current = endId;
                while (current !== null) {
                    path.push(current);
                    current = predecessors[current];
                }
                path.reverse();
                return path[0] === startId ? path : null;
            }

            // Yen's Kæœ€çŸ­è·¯å¾„ç®—æ³•
            yenKShortestPaths(startId, endId, K) {
                const kPaths = [];
                const firstPath = this.dijkstra(startId, endId);
                if (!firstPath) return [];
                kPaths.push(firstPath);

                for (let k = 1; k < K; k++) {
                    const prevPath = kPaths[k - 1];
                    const candidates = [];

                    for (let i = 0; i < prevPath.length - 1; i++) {
                        const spurNode = prevPath[i];
                        const rootPath = prevPath.slice(0, i + 1);
                        const removedEdges = new Map();

                        kPaths.forEach(path => {
                            if (path.slice(0, i + 1).join(',') === rootPath.join(',')) {
                                const edgeKey = `${path[i]}-${path[i + 1]}`;
                                if (this.edges[path[i]]?.[path[i + 1]]) {
                                    removedEdges.set(edgeKey, this.edges[path[i]][path[i + 1]]);
                                    delete this.edges[path[i]][path[i + 1]];
                                }
                            }
                        });

                        const spurPath = this.dijkstra(spurNode, endId);
                        if (spurPath) {
                            const newPath = [...rootPath.slice(0, -1), ...spurPath];
                            const isDuplicate = kPaths.some(existPath =>
                                existPath.length === newPath.length && existPath.join(',') === newPath.join(',')
                            );
                            if (!isDuplicate) {
                                candidates.push({ path: newPath, weight: this.calculatePathWeight(newPath) });
                            }
                        }

                        // æ¢å¤åˆ é™¤çš„è¾¹
                        removedEdges.forEach((edge, edgeKey) => {
                            const [u, v] = edgeKey.split('-');
                            if (!this.edges[u]) this.edges[u] = {};
                            this.edges[u][v] = edge;
                        });
                    }

                    if (candidates.length === 0) break;
                    candidates.sort((a, b) => a.weight - b.weight);
                    kPaths.push(candidates[0].path);
                }

                return kPaths;
            }
        }

        // ===================== æ•™å­¦æ¥¼æ¨¡å¼ =====================
        class TeachingMode extends BaseMode {
            constructor() {
                const config = {
                    SCALE: 50000000,
                    ALTITUDE_SCALE: 500,
                    X_OFFSET: -17000,
                    Y_OFFSET: -29000,
                    Z_OFFSET: 15000,
                    K: 2,
                    BOX_SIZE: { x: 2000, y: 500, z: 2000 },
                    EDGE_RADIUS: 80,
                    PATH_RADIUS: 80,
                    STAIR_PENALTY: true
                };
                super('teaching', config, 'path_data_6J.json');
            }

            // æ•™å­¦æ¥¼ä¸“å±æƒé‡ç®—æ³•
            calculateEdgeWeight(startId, endId) {
                if (!this.edges[startId] || !this.edges[startId][endId]) return Infinity;
                const start = this.nodes[startId];
                const end = this.nodes[endId];
                const edge = this.edges[startId][endId];

                // åŸºç¡€è·ç¦»è®¡ç®—
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                let geoDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const altDiff = Math.abs(end.alt - start.alt);
                if (geoDist < 0.1) geoDist = altDiff + 10;

                // æ¥¼æ¢¯æƒ©ç½š
                let stairPenalty = 1;
                const isStairEdge = startId.includes("STAIR") || endId.includes("STAIR");
                if (isStairEdge) stairPenalty = altDiff < 5 ? 30 : 80;

                // æ‹¥æŒ¤åº¦æƒ©ç½š
                const maxCap = edge.max_cap || 1;
                const actualFlow = edge.actual_flow || 0;
                const congestion = actualFlow / maxCap;
                let crowdPenalty = 1;
                if (congestion <= 0.5) crowdPenalty = Math.pow(4, 5 * congestion);
                else if (congestion <= 0.8) crowdPenalty = Math.pow(8, 6 * (congestion - 0.5)) * 32;
                else crowdPenalty = Math.pow(15, 8 * (congestion - 0.8)) * 8384;

                // é“è·¯ç±»å‹ç³»æ•°
                const roadCoeff = edge.road_type === 'main' ? 0.9 : 1.2;

                const finalWeight = geoDist * roadCoeff * stairPenalty * crowdPenalty;
                return finalWeight > 1e12 ? 1e12 : finalWeight;
            }
        }

        // ===================== æ ¡å›­æ¨¡å¼ =====================
        class CampusMode extends BaseMode {
            constructor() {
                const config = {
                    SCALE: 10000000,
                    ALTITUDE_SCALE: 500,
                    X_OFFSET: -40000,
                    Y_OFFSET: -25000,
                    Z_OFFSET: 50000,
                    K: 2,
                    BOX_SIZE: { x: 2000, y: 300, z: 2000 },
                    EDGE_RADIUS: 150,
                    PATH_RADIUS: 150,
                    STAIR_PENALTY: false
                };
                super('campus', config, 'path_data_campus.json');
            }

            // æ ¡å›­ä¸“å±æƒé‡ç®—æ³•
            calculateEdgeWeight(startId, endId) {
                if (!this.edges[startId] || !this.edges[startId][endId]) return Infinity;
                const start = this.nodes[startId];
                const end = this.nodes[endId];
                const edge = this.edges[startId][endId];

                // åŸºç¡€è·ç¦»è®¡ç®—
                const x1 = start.lon * 111000;
                const y1 = start.lat * 111000;
                const x2 = end.lon * 111000;
                const y2 = end.lat * 111000;
                let geoDist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const altDiff = Math.abs(end.alt - start.alt);
                if (geoDist < 0.1) geoDist = altDiff + 50;

                // æ— æ¥¼æ¢¯æƒ©ç½š
                const stairPenalty = 1;

                // æ‹¥æŒ¤åº¦æƒ©ç½š
                const maxCap = edge.max_cap || 1;
                const actualFlow = edge.actual_flow || 0;
                const congestion = actualFlow / maxCap;
                let crowdPenalty = 1;
                if (congestion <= 0.5) crowdPenalty = Math.pow(2, 5 * congestion);
                else if (congestion <= 0.8) crowdPenalty = Math.pow(4, 6 * (congestion - 0.5)) * 16;
                else crowdPenalty = Math.pow(8, 8 * (congestion - 0.8)) * 4096;

                // é“è·¯ç±»å‹ç³»æ•°
                const roadCoeff = edge.road_type === 'main' ? 0.7 : 1.3;

                const finalWeight = geoDist * roadCoeff * stairPenalty * crowdPenalty;
                return finalWeight > 1e12 ? 1e12 : finalWeight;
            }

            // è¦†å†™æ ¡å›­æ¨¡å¼èŠ‚ç‚¹ç»˜åˆ¶
            drawNodes() {
                for (const id in this.nodes) {
                    const node = this.nodes[id];
                    const pos = this.lonlatTo3d(node.lon, node.lat, node.alt);
                    const alt = node.alt;

                    const boxGeo = new THREE.BoxGeometry(
                        this.config.BOX_SIZE.x,
                        this.config.BOX_SIZE.y,
                        this.config.BOX_SIZE.z
                    );

                    const baseColor = 0x999999;
                    const materials = {
                        default: new THREE.MeshStandardMaterial({ 
                            color: baseColor, roughness: 0.7, metalness: 0.1,
                            emissive: 0x000000, emissiveIntensity: 0 
                        }),
                        hover: new THREE.MeshStandardMaterial({ 
                            color: baseColor, roughness: 0.7, metalness: 0.1,
                            emissive: 0xffff00, emissiveIntensity: 0.5 
                        }),
                        start: new THREE.MeshStandardMaterial({ 
                            color: 0x4CAF50, roughness: 0.7, metalness: 0.2,
                            emissive: 0x00ff00, emissiveIntensity: 0.3 
                        }),
                        end: new THREE.MeshStandardMaterial({ 
                            color: 0x0000ff, roughness: 0.7, metalness: 0.2,
                            emissive: 0x0000ff, emissiveIntensity: 0.3 
                        })
                    };

                    const boxMesh = new THREE.Mesh(boxGeo, materials.default);
                    boxMesh.position.copy(pos);
                    boxMesh.userData = { id, alt, lon: node.lon, lat: node.lat };
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    scene.add(boxMesh);
                    this.nodeMeshes.push(boxMesh);

                    const labelDiv = document.createElement('div');
                    labelDiv.classList.add('css2d-label');
                    labelDiv.style.fontSize = '14px';
                    labelDiv.style.fontWeight = 'bold';
                    labelDiv.style.color = '#333';
                    labelDiv.style.background = 'rgba(255,255,255,0.8)';
                    labelDiv.style.padding = '3px 8px';
                    labelDiv.style.borderRadius = '3px';
                    labelDiv.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
                    labelDiv.textContent = id;

                    if (!id.includes("CROSS") && !id.includes("TURN")) {
                        const label = new THREE.CSS2DObject(labelDiv);
                        label.position.set(0, this.config.BOX_SIZE.y / 2 + 300, 0);
                        boxMesh.add(label);
                    }

                    this.nodes[id] = {
                        ...node,
                        mesh: boxMesh,
                        materials,
                        originalScale: new THREE.Vector3(1, 1, 1)
                    };
                }
            }
        }

        // ===================== æ¨¡å¼åˆ‡æ¢é€»è¾‘ =====================
        function switchMode(modeType) {
            if (currentModeInstance) {
                currentModeInstance.destroy();
                currentModeInstance = null;
            }

            if (modeType === 'teaching') {
                currentModeInstance = new TeachingMode();
            } else if (modeType === 'campus') {
                currentModeInstance = new CampusMode();
            }

            currentModeInstance.loadData();

            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.mode-btn[data-mode="${modeType}"]`).classList.add('active');
        }

        // ===================== é¼ æ ‡äº¤äº’é€»è¾‘ =====================
        function onMouseMove(event) {
            if (!currentModeInstance) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // é‡ç½®ä¸Šä¸€ä¸ªæ‚¬åœèŠ‚ç‚¹
            if (hoveredNodeId && !currentModeInstance.selectedNodes.includes(hoveredNodeId)) {
                const prevNode = currentModeInstance.nodes[hoveredNodeId];
                if (prevNode) {
                    prevNode.mesh.material = prevNode.materials.default;
                    prevNode.mesh.scale.copy(prevNode.originalScale);
                }
                hoveredNodeId = null;
            }

            // æ‚¬åœæ–°èŠ‚ç‚¹
            const intersects = raycaster.intersectObjects(currentModeInstance.nodeMeshes, false);
            if (intersects.length > 0) {
                const targetNode = intersects[0].object;
                const nodeId = targetNode.userData.id;
                if (!currentModeInstance.selectedNodes.includes(nodeId)) {
                    hoveredNodeId = nodeId;
                    const currNode = currentModeInstance.nodes[nodeId];
                    if (currNode) {
                        currNode.mesh.material = currNode.materials.hover;
                        currNode.mesh.scale.lerp(new THREE.Vector3(1.3, 1.3, 1.3), 0.1);
                    }
                }
            }
        }

        function onMouseClick() {
            if (!currentModeInstance) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(currentModeInstance.nodeMeshes, false);

            if (intersects.length === 0) {
                updateInfo(`è¯·ç‚¹å‡»æœ‰æ•ˆ${currentModeInstance.modeName === 'teaching' ? 'æ•™å®¤' : 'å»ºç­‘'}ï¼ˆç°è‰²é•¿æ–¹ä½“ï¼‰`, true);
                return;
            }

            const targetNode = intersects[0].object;
            const nodeId = targetNode.userData.id;
            const mode = currentModeInstance;

            // æ¸…ç©ºè·¯å¾„
            mode.pathMeshes.forEach(mesh => scene.remove(mesh));
            mode.pathMeshes = [];
            document.getElementById('path-detail').style.display = 'none';
            document.getElementById('path1').innerHTML = '';
            document.getElementById('path2').innerHTML = '';

            // é€‰æ‹©èµ·ç‚¹
            if (mode.selectedNodes.length === 0) {
                mode.selectedNodes.push(nodeId);
                mode.nodes[nodeId].mesh.material = mode.nodes[nodeId].materials.start;
                mode.nodes[nodeId].mesh.scale.copy(mode.nodes[nodeId].originalScale);
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            }
            // é€‰æ‹©ç»ˆç‚¹
            else if (mode.selectedNodes.length === 1) {
                if (nodeId === mode.selectedNodes[0]) {
                    updateInfo("âŒ ä¸èƒ½é€‰æ‹©åŒä¸€é•¿æ–¹ä½“ä½œä¸ºç»ˆç‚¹ï¼Œè¯·é‡æ–°ç‚¹å‡»", true);
                    return;
                }
                mode.selectedNodes.push(nodeId);
                mode.nodes[nodeId].mesh.material = mode.nodes[nodeId].materials.end;
                mode.nodes[nodeId].mesh.scale.copy(mode.nodes[nodeId].originalScale);
                updateInfo(`ğŸ” æ­£åœ¨è®¡ç®—è·¯å¾„ï¼š${mode.selectedNodes[0]} â†’ ${nodeId}`);

                // è®¡ç®—Kæœ€çŸ­è·¯å¾„
                const kPaths = mode.yenKShortestPaths(mode.selectedNodes[0], nodeId, mode.config.K);
                if (kPaths.length === 0) {
                    updateInfo(`âŒ æœªæ‰¾åˆ°ä» ${mode.selectedNodes[0]} åˆ° ${nodeId} çš„è·¯å¾„`, true);
                } else {
                    updateInfo(`âœ… æ‰¾åˆ° ${kPaths.length} æ¡è·¯å¾„ï¼ŒæŒ‰ESCé‡æ–°é€‰æ‹©`);
                    const pathColors = [0x00ffff, 0x8800ff];
                    kPaths.forEach((path, idx) => {
                        mode.drawPath(path, idx + 1, pathColors[idx]);
                    });
                }
            }
            // é‡æ–°é€‰æ‹©èµ·ç‚¹
            else {
                mode.selectedNodes.forEach(id => {
                    mode.nodes[id].mesh.material = mode.nodes[id].materials.default;
                    mode.nodes[id].mesh.scale.copy(mode.nodes[id].originalScale);
                });
                mode.selectedNodes = [nodeId];
                mode.nodes[nodeId].mesh.material = mode.nodes[nodeId].materials.start;
                updateInfo(`âœ… èµ·ç‚¹å·²é€‰æ‹©ï¼š${nodeId}ï¼ˆç»¿è‰²ï¼‰ï¼Œç‚¹å‡»é€‰æ‹©ç»ˆç‚¹ï¼ˆè“è‰²ï¼‰`);
            }
        }

        // ===================== èŠ‚ç‚¹æŸ¥æ‰¾é¢æ¿åˆå§‹åŒ– =====================
        function initSearchPanel() {
            const startInput = document.getElementById('start-node-input');
            const endInput = document.getElementById('end-node-input');
            const searchBtn = document.getElementById('search-path-btn');
            const searchTip = document.getElementById('search-tip');

            // è¾“å…¥æ¡†è‡ªåŠ¨è¡¥å…¨
            function initInputAutoComplete(inputEl) {
                const dropdown = document.createElement('div');
                dropdown.style.cssText = `
                    position: absolute;
                    background: rgba(255,255,255,0.95);
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    max-height: 180px;
                    overflow-y: auto;
                    z-index: 300;
                    display: none;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    font-size: 12px;
                `;
                inputEl.parentNode.appendChild(dropdown);

                // è¾“å…¥ç›‘å¬
                inputEl.addEventListener('input', () => {
                    if (!currentModeInstance) return;
                    const inputVal = inputEl.value.trim().toLowerCase();
                    if (inputVal.length < 1) {
                        dropdown.style.display = 'none';
                        return;
                    }

                    // åŒ¹é…èŠ‚ç‚¹
                    const matchNodes = Object.keys(currentModeInstance.nodes).filter(nodeId => 
                        nodeId.toLowerCase().includes(inputVal)
                    );

                    if (matchNodes.length > 0) {
                        dropdown.innerHTML = matchNodes.map(nodeId => `
                            <div style="padding: 6px 8px; cursor: pointer; transition: background 0.2s;">
                                ${nodeId}
                            </div>
                        `).join('');
                        dropdown.style.display = 'block';

                        // å®šä½ä¸‹æ‹‰æ¡†
                        const rect = inputEl.getBoundingClientRect();
                        const parentRect = inputEl.parentNode.getBoundingClientRect();
                        dropdown.style.top = `${rect.bottom - parentRect.top + 2}px`;
                        dropdown.style.left = `${rect.left - parentRect.left}px`;
                        dropdown.style.width = `${rect.width}px`;

                        // ç‚¹å‡»é€‰é¡¹å¡«å……
                        dropdown.querySelectorAll('div').forEach(item => {
                            item.addEventListener('click', () => {
                                inputEl.value = item.textContent;
                                dropdown.style.display = 'none';
                                searchTip.style.display = 'none';
                            });
                            item.addEventListener('mouseover', () => {
                                item.style.background = '#f5f9ff';
                            });
                            item.addEventListener('mouseout', () => {
                                item.style.background = 'transparent';
                            });
                        });
                    } else {
                        dropdown.style.display = 'none';
                    }
                });

                // ç‚¹å‡»ç©ºç™½å¤„å…³é—­
                document.addEventListener('click', (e) => {
                    if (!inputEl.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.style.display = 'none';
                    }
                });

                // å›è½¦å…³é—­
                inputEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        dropdown.style.display = 'none';
                    }
                });
            }

            // åŒ¹é…èŠ‚ç‚¹åï¼ˆæ¨¡ç³ŠåŒ¹é…ï¼‰
            function matchNodeId(inputText) {
                if (!currentModeInstance || !inputText) return null;
                const lowerText = inputText.trim().toLowerCase();
                for (const id in currentModeInstance.nodes) {
                    if (id.toLowerCase().includes(lowerText)) {
                        return id;
                    }
                }
                return null;
            }

            // æœç´¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            searchBtn.addEventListener('click', () => {
                if (!currentModeInstance) {
                    searchTip.style.display = 'block';
                    searchTip.textContent = 'è¯·å…ˆé€‰æ‹©æ¨¡å¼ï¼ˆæ•™å­¦æ¥¼/æ ¡å›­ï¼‰';
                    return;
                }

                searchTip.style.display = 'none';
                const startId = matchNodeId(startInput.value);
                const endId = matchNodeId(endInput.value);

                if (!startId) {
                    searchTip.style.display = 'block';
                    searchTip.textContent = `æœªæ‰¾åˆ°èµ·ç‚¹ï¼š${startInput.value}`;
                    return;
                }
                if (!endId) {
                    searchTip.style.display = 'block';
                    searchTip.textContent = `æœªæ‰¾åˆ°ç»ˆç‚¹ï¼š${endInput.value}`;
                    return;
                }
                if (startId === endId) {
                    searchTip.style.display = 'block';
                    searchTip.textContent = 'èµ·ç‚¹å’Œç»ˆç‚¹ä¸èƒ½ç›¸åŒ';
                    return;
                }

                // é‡ç½®åŸæœ‰é€‰ä¸­çŠ¶æ€
                if (currentModeInstance.selectedNodes.length > 0) {
                    currentModeInstance.selectedNodes.forEach(id => {
                        currentModeInstance.nodes[id].mesh.material = currentModeInstance.nodes[id].materials.default;
                        currentModeInstance.nodes[id].mesh.scale.copy(currentModeInstance.nodes[id].originalScale);
                    });
                }

                // è®¾ç½®æ–°èµ·ç»ˆç‚¹å¹¶è®¡ç®—è·¯å¾„
                currentModeInstance.selectedNodes = [startId, endId];
                currentModeInstance.nodes[startId].mesh.material = currentModeInstance.nodes[startId].materials.start;
                currentModeInstance.nodes[endId].mesh.material = currentModeInstance.nodes[endId].materials.end;
        
                currentModeInstance.pathMeshes.forEach(mesh => scene.remove(mesh));
                currentModeInstance.pathMeshes = [];

                updateInfo(`ğŸ” æ­£åœ¨è®¡ç®—è·¯å¾„ï¼š${startId} â†’ ${endId}`);
                const kPaths = currentModeInstance.yenKShortestPaths(startId, endId, currentModeInstance.config.K);
                if (kPaths.length === 0) {
                    updateInfo(`âŒ æœªæ‰¾åˆ°ä» ${startId} åˆ° ${endId} çš„è·¯å¾„`, true);
                    searchTip.style.display = 'block';
                    searchTip.textContent = `æœªæ‰¾åˆ°ä» ${startId} åˆ° ${endId} çš„è·¯å¾„`;
                } else {
                    updateInfo(`âœ… æ‰¾åˆ° ${kPaths.length} æ¡è·¯å¾„ï¼ŒæŒ‰ESCé‡æ–°é€‰æ‹©`);
                    const pathColors = [0x00ffff, 0x8800ff];
                    kPaths.forEach((path, idx) => {
                        currentModeInstance.drawPath(path, idx + 1, pathColors[idx]);
                    });
                }
            });

            // å›è½¦è§¦å‘æœç´¢
            startInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') searchBtn.click();
            });
            endInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') searchBtn.click();
            });
        
            // åˆå§‹åŒ–è‡ªåŠ¨è¡¥å…¨
            initInputAutoComplete(startInput);
            initInputAutoComplete(endInput);
        }

        // ===================== é¡µé¢åˆå§‹åŒ– =====================
        window.addEventListener('load', () => {
            // åˆå§‹åŒ–å…¨å±€åœºæ™¯
            initGlobalScene();

            // ç»‘å®šæ¨¡å¼åˆ‡æ¢äº‹ä»¶
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    const modeType = this.getAttribute('data-mode');
                    switchMode(modeType);
                });
            });

            // ç»‘å®šé¼ æ ‡äº¤äº’äº‹ä»¶
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            // é»˜è®¤åŠ è½½æ•™å­¦æ¥¼æ¨¡å¼
            switchMode('teaching');
            initSearchPanel();

            // åˆå§‹åŒ–é¢æ¿æ‹–æ‹½
            makePanelDraggable(document.getElementById('mode-panel'));
            makePanelDraggable(document.getElementById('path-detail'));
            makePanelDraggable(document.getElementById('search-panel'));
        });
    </script>
</body>
</html>
